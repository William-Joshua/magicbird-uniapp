{"version":3,"sources":["index.js","source-map.js","printer.js","buffer.js","node/index.js","node/whitespace.js","node/parentheses.js","generators/index.js","generators/template-literals.js","generators/expressions.js","generators/statements.js","generators/classes.js","generators/methods.js","generators/modules.js","generators/types.js","generators/flow.js","generators/base.js","generators/jsx.js","generators/typescript.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AIZA,AFMA,ADGA;AELA,AHSA,AIZA,AFMA,ADGA;AELA,AHSA,AIZA,AFMA,ADGA;AELA,AHSA,AIZA,ACHA,AHSA,ADGA;AELA,AHSA,AIZA,ACHA,AHSA,ADGA;AELA,AHSA,AIZA,ACHA,AHSA,ADGA;AELA,AHSA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AHSA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AHSA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AIZA,APqBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AIZA,APqBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AIZA,APqBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AIZA,ACHA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AIZA,ACHA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AIZA,ACHA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AMlBA,AFMA,ACHA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AMlBA,AFMA,ACHA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AMlBA,AFMA,ACHA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AMlBA,AFMA,AGTA,AFMA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AMlBA,AFMA,AGTA,AFMA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AMlBA,AFMA,AGTA,AFMA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AQxBA,AFMA,AFMA,AGTA,AFMA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AQxBA,AFMA,AFMA,AGTA,AFMA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AQxBA,AFMA,AFMA,AGTA,AFMA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AQxBA,AFMA,AFMA,AKfA,AFMA,AFMA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AQxBA,AFMA,AFMA,AKfA,AFMA,AFMA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AQxBA,AFMA,AFMA,AKfA,AFMA,AFMA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AQxBA,AFMA,AFMA,AKfA,ACHA,AHSA,AFMA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AQxBA,AFMA,AFMA,AKfA,ACHA,AHSA,AFMA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AQxBA,AFMA,AFMA,AKfA,ACHA,AHSA,AFMA,ARwBA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AQxBA,AFMA,AFMA,AKfA,ACHA,AHSA,AFMA,AMlBA,Ad0CA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AQxBA,AFMA,AFMA,AKfA,ACHA,AHSA,AFMA,AMlBA,Ad0CA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AQxBA,AFMA,AFMA,AKfA,ACHA,AHSA,AFMA,AMlBA,Ad0CA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AQxBA,AFMA,AMlBA,ARwBA,AKfA,ACHA,AHSA,AFMA,AMlBA,Ad0CA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AQxBA,AFMA,AMlBA,ARwBA,AKfA,ACHA,AHSA,AFMA,AMlBA,Ad0CA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AQxBA,AFMA,AMlBA,ARwBA,AKfA,ACHA,AHSA,AFMA,AMlBA,Ad0CA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AKfA,ACHA,AHSA,AFMA,AMlBA,Ad0CA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AKfA,ACHA,AHSA,AFMA,AMlBA,Ad0CA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AKfA,ACHA,AHSA,AFMA,AMlBA,Ad0CA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AFMA,AMlBA,Ad0CA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AFMA,AMlBA,Ad0CA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AFMA,AMlBA,Ad0CA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AFMA,AMlBA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AFMA,AMlBA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AFMA,AMlBA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA,ADGA;AELA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AlBsDA,AIZA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,Ad0CA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,Ad0CA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,Ad0CA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,Ad0CA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,Ad0CA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,Ad0CA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,Ad0CA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,Ad0CA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,Ad0CA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,Ad0CA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,Ad0CA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,Ad0CA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,Ad0CA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,Ad0CA,AENA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AavCA,ALeA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,ARwBA,AU9BA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,ADGA,AHSA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AENA,AJYA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AENA,AJYA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AENA,AJYA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AENA,AJYA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AQxBA,AFMA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AIZA,AIZA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AZoCA,AJYA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AhBgDA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AhBgDA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AhBgDA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AhBgDA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AhBgDA;ACFA,AMlBA,AMlBA,ALeA,AQxBA,AhBgDA;ACFA,AMlBA,AMlBA,AGTA,AhBgDA;ACFA,AMlBA,AMlBA,AGTA,AhBgDA;ACFA,AMlBA,AMlBA,AGTA,AhBgDA;AOpBA,AMlBA,AGTA,AhBgDA;AOpBA,AMlBA,AGTA,AhBgDA;AOpBA,AMlBA,AGTA,AhBgDA;AOpBA,AMlBA,AGTA,AhBgDA;AOpBA,AMlBA,AGTA,AhBgDA;AOpBA,AMlBA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA,AhBgDA;AatCA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CodeGenerator = void 0;\nexports.default = generate;\n\nvar _sourceMap = require(\"./source-map\");\n\nvar _printer = require(\"./printer\");\n\nclass Generator extends _printer.default {\n  constructor(ast, opts = {}, code) {\n    const format = normalizeOptions(code, opts);\n    const map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;\n    super(format, map);\n    this.ast = void 0;\n    this.ast = ast;\n  }\n\n  generate() {\n    return super.generate(this.ast);\n  }\n\n}\n\nfunction normalizeOptions(code, opts) {\n  const format = {\n    auxiliaryCommentBefore: opts.auxiliaryCommentBefore,\n    auxiliaryCommentAfter: opts.auxiliaryCommentAfter,\n    shouldPrintComment: opts.shouldPrintComment,\n    retainLines: opts.retainLines,\n    retainFunctionParens: opts.retainFunctionParens,\n    comments: opts.comments == null || opts.comments,\n    compact: opts.compact,\n    minified: opts.minified,\n    concise: opts.concise,\n    indent: {\n      adjustMultilineComment: true,\n      style: \"  \",\n      base: 0\n    },\n    jsescOption: Object.assign({\n      quotes: \"double\",\n      wrap: true,\n      minimal: false\n    }, opts.jsescOption),\n    recordAndTupleSyntaxType: opts.recordAndTupleSyntaxType,\n    topicToken: opts.topicToken\n  };\n  {\n    format.decoratorsBeforeExport = !!opts.decoratorsBeforeExport;\n    format.jsonCompatibleStrings = opts.jsonCompatibleStrings;\n  }\n\n  if (format.minified) {\n    format.compact = true;\n\n    format.shouldPrintComment = format.shouldPrintComment || (() => format.comments);\n  } else {\n    format.shouldPrintComment = format.shouldPrintComment || (value => format.comments || value.includes(\"@license\") || value.includes(\"@preserve\"));\n  }\n\n  if (format.compact === \"auto\") {\n    format.compact = code.length > 500000;\n\n    if (format.compact) {\n      console.error(\"[BABEL] Note: The code generator has deoptimised the styling of \" + `${opts.filename} as it exceeds the max of ${\"500KB\"}.`);\n    }\n  }\n\n  if (format.compact) {\n    format.indent.adjustMultilineComment = false;\n  }\n\n  return format;\n}\n\nclass CodeGenerator {\n  constructor(ast, opts, code) {\n    this._generator = void 0;\n    this._generator = new Generator(ast, opts, code);\n  }\n\n  generate() {\n    return this._generator.generate();\n  }\n\n}\n\nexports.CodeGenerator = CodeGenerator;\n\nfunction generate(ast, opts, code) {\n  const gen = new Generator(ast, opts, code);\n  return gen.generate();\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _genMapping = require(\"@jridgewell/gen-mapping\");\n\nclass SourceMap {\n  constructor(opts, code) {\n    var _opts$sourceFileName;\n\n    this._map = void 0;\n    this._rawMappings = void 0;\n    this._sourceFileName = void 0;\n    this._lastGenLine = 0;\n    this._lastSourceLine = 0;\n    this._lastSourceColumn = 0;\n    const map = this._map = new _genMapping.GenMapping({\n      sourceRoot: opts.sourceRoot\n    });\n    this._sourceFileName = (_opts$sourceFileName = opts.sourceFileName) == null ? void 0 : _opts$sourceFileName.replace(/\\\\/g, \"/\");\n    this._rawMappings = undefined;\n\n    if (typeof code === \"string\") {\n      (0, _genMapping.setSourceContent)(map, this._sourceFileName, code);\n    } else if (typeof code === \"object\") {\n      Object.keys(code).forEach(sourceFileName => {\n        (0, _genMapping.setSourceContent)(map, sourceFileName.replace(/\\\\/g, \"/\"), code[sourceFileName]);\n      });\n    }\n  }\n\n  get() {\n    return (0, _genMapping.toEncodedMap)(this._map);\n  }\n\n  getDecoded() {\n    return (0, _genMapping.toDecodedMap)(this._map);\n  }\n\n  getRawMappings() {\n    return this._rawMappings || (this._rawMappings = (0, _genMapping.allMappings)(this._map));\n  }\n\n  mark(generated, line, column, identifierName, filename) {\n    this._rawMappings = undefined;\n    (0, _genMapping.maybeAddMapping)(this._map, {\n      name: identifierName,\n      generated,\n      source: line == null ? undefined : (filename == null ? void 0 : filename.replace(/\\\\/g, \"/\")) || this._sourceFileName,\n      original: line == null ? undefined : {\n        line: line,\n        column: column\n      }\n    });\n  }\n\n}\n\nexports.default = SourceMap;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _buffer = require(\"./buffer\");\n\nvar n = require(\"./node\");\n\nvar generatorFunctions = require(\"./generators\");\n\nconst SCIENTIFIC_NOTATION = /e/i;\nconst ZERO_DECIMAL_INTEGER = /\\.0+$/;\nconst NON_DECIMAL_LITERAL = /^0[box]/;\nconst PURE_ANNOTATION_RE = /^\\s*[@#]__PURE__\\s*$/;\nconst {\n  needsParens,\n  needsWhitespaceAfter,\n  needsWhitespaceBefore\n} = n;\n\nclass Printer {\n  constructor(format, map) {\n    this.inForStatementInitCounter = 0;\n    this._printStack = [];\n    this._indent = 0;\n    this._indentChar = 0;\n    this._indentRepeat = 0;\n    this._insideAux = false;\n    this._parenPushNewlineState = null;\n    this._noLineTerminator = false;\n    this._printAuxAfterOnNextUserNode = false;\n    this._printedComments = new Set();\n    this._endsWithInteger = false;\n    this._endsWithWord = false;\n    this.format = format;\n    this._buf = new _buffer.default(map);\n    this._indentChar = format.indent.style.charCodeAt(0);\n    this._indentRepeat = format.indent.style.length;\n  }\n\n  generate(ast) {\n    this.print(ast);\n\n    this._maybeAddAuxComment();\n\n    return this._buf.get();\n  }\n\n  indent() {\n    if (this.format.compact || this.format.concise) return;\n    this._indent++;\n  }\n\n  dedent() {\n    if (this.format.compact || this.format.concise) return;\n    this._indent--;\n  }\n\n  semicolon(force = false) {\n    this._maybeAddAuxComment();\n\n    if (force) {\n      this._appendChar(59);\n    } else {\n      this._queue(59);\n    }\n  }\n\n  rightBrace() {\n    if (this.format.minified) {\n      this._buf.removeLastSemicolon();\n    }\n\n    this.tokenChar(125);\n  }\n\n  space(force = false) {\n    if (this.format.compact) return;\n\n    if (force) {\n      this._space();\n    } else if (this._buf.hasContent()) {\n      const lastCp = this.getLastChar();\n\n      if (lastCp !== 32 && lastCp !== 10) {\n        this._space();\n      }\n    }\n  }\n\n  word(str) {\n    if (this._endsWithWord || str.charCodeAt(0) === 47 && this.endsWith(47)) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n\n    this._append(str, false);\n\n    this._endsWithWord = true;\n  }\n\n  number(str) {\n    this.word(str);\n    this._endsWithInteger = Number.isInteger(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;\n  }\n\n  token(str, maybeNewline = false) {\n    const lastChar = this.getLastChar();\n    const strFirst = str.charCodeAt(0);\n\n    if (lastChar === 33 && str === \"--\" || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n\n    this._append(str, maybeNewline);\n  }\n\n  tokenChar(char) {\n    const lastChar = this.getLastChar();\n\n    if (char === 43 && lastChar === 43 || char === 45 && lastChar === 45 || char === 46 && this._endsWithInteger) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n\n    this._appendChar(char);\n  }\n\n  newline(i = 1) {\n    if (this.format.retainLines || this.format.compact) return;\n\n    if (this.format.concise) {\n      this.space();\n      return;\n    }\n\n    const charBeforeNewline = this.endsWithCharAndNewline();\n    if (charBeforeNewline === 10) return;\n\n    if (charBeforeNewline === 123 || charBeforeNewline === 58) {\n      i--;\n    }\n\n    if (i <= 0) return;\n\n    for (let j = 0; j < i; j++) {\n      this._newline();\n    }\n  }\n\n  endsWith(char) {\n    return this.getLastChar() === char;\n  }\n\n  getLastChar() {\n    return this._buf.getLastChar();\n  }\n\n  endsWithCharAndNewline() {\n    return this._buf.endsWithCharAndNewline();\n  }\n\n  removeTrailingNewline() {\n    this._buf.removeTrailingNewline();\n  }\n\n  exactSource(loc, cb) {\n    this._catchUp(\"start\", loc);\n\n    this._buf.exactSource(loc, cb);\n  }\n\n  source(prop, loc) {\n    this._catchUp(prop, loc);\n\n    this._buf.source(prop, loc);\n  }\n\n  withSource(prop, loc, cb) {\n    this._catchUp(prop, loc);\n\n    this._buf.withSource(prop, loc, cb);\n  }\n\n  _space() {\n    this._queue(32);\n  }\n\n  _newline() {\n    this._queue(10);\n  }\n\n  _append(str, maybeNewline) {\n    this._maybeAddParen(str);\n\n    this._maybeIndent(str.charCodeAt(0));\n\n    this._buf.append(str, maybeNewline);\n\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _appendChar(char) {\n    this._maybeAddParenChar(char);\n\n    this._maybeIndent(char);\n\n    this._buf.appendChar(char);\n\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _queue(char) {\n    this._maybeAddParenChar(char);\n\n    this._maybeIndent(char);\n\n    this._buf.queue(char);\n\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _maybeIndent(firstChar) {\n    if (this._indent && firstChar !== 10 && this.endsWith(10)) {\n      this._buf.queueIndentation(this._indentChar, this._getIndent());\n    }\n  }\n\n  _maybeAddParenChar(char) {\n    const parenPushNewlineState = this._parenPushNewlineState;\n    if (!parenPushNewlineState) return;\n\n    if (char === 32) {\n      return;\n    }\n\n    if (char !== 10) {\n      this._parenPushNewlineState = null;\n      return;\n    }\n\n    this.tokenChar(40);\n    this.indent();\n    parenPushNewlineState.printed = true;\n  }\n\n  _maybeAddParen(str) {\n    const parenPushNewlineState = this._parenPushNewlineState;\n    if (!parenPushNewlineState) return;\n    const len = str.length;\n    let i;\n\n    for (i = 0; i < len && str.charCodeAt(i) === 32; i++) continue;\n\n    if (i === len) {\n      return;\n    }\n\n    const cha = str.charCodeAt(i);\n\n    if (cha !== 10) {\n      if (cha !== 47 || i + 1 === len) {\n        this._parenPushNewlineState = null;\n        return;\n      }\n\n      const chaPost = str.charCodeAt(i + 1);\n\n      if (chaPost === 42) {\n        if (PURE_ANNOTATION_RE.test(str.slice(i + 2, len - 2))) {\n          return;\n        }\n      } else if (chaPost !== 47) {\n        this._parenPushNewlineState = null;\n        return;\n      }\n    }\n\n    this.tokenChar(40);\n    this.indent();\n    parenPushNewlineState.printed = true;\n  }\n\n  _catchUp(prop, loc) {\n    if (!this.format.retainLines) return;\n    const pos = loc ? loc[prop] : null;\n\n    if ((pos == null ? void 0 : pos.line) != null) {\n      const count = pos.line - this._buf.getCurrentLine();\n\n      for (let i = 0; i < count; i++) {\n        this._newline();\n      }\n    }\n  }\n\n  _getIndent() {\n    return this._indentRepeat * this._indent;\n  }\n\n  printTerminatorless(node, parent, isLabel) {\n    if (isLabel) {\n      this._noLineTerminator = true;\n      this.print(node, parent);\n      this._noLineTerminator = false;\n    } else {\n      const terminatorState = {\n        printed: false\n      };\n      this._parenPushNewlineState = terminatorState;\n      this.print(node, parent);\n\n      if (terminatorState.printed) {\n        this.dedent();\n        this.newline();\n        this.tokenChar(41);\n      }\n    }\n  }\n\n  print(node, parent, noLineTerminator) {\n    if (!node) return;\n    const nodeType = node.type;\n    const format = this.format;\n    const oldConcise = format.concise;\n\n    if (node._compact) {\n      format.concise = true;\n    }\n\n    const printMethod = this[nodeType];\n\n    if (printMethod === undefined) {\n      throw new ReferenceError(`unknown node of type ${JSON.stringify(nodeType)} with constructor ${JSON.stringify(node.constructor.name)}`);\n    }\n\n    this._printStack.push(node);\n\n    const oldInAux = this._insideAux;\n    this._insideAux = node.loc == undefined;\n\n    this._maybeAddAuxComment(this._insideAux && !oldInAux);\n\n    let shouldPrintParens;\n\n    if (format.retainFunctionParens && nodeType === \"FunctionExpression\" && node.extra && node.extra.parenthesized) {\n      shouldPrintParens = true;\n    } else {\n      shouldPrintParens = needsParens(node, parent, this._printStack);\n    }\n\n    if (shouldPrintParens) this.tokenChar(40);\n\n    this._printLeadingComments(node);\n\n    const loc = nodeType === \"Program\" || nodeType === \"File\" ? null : node.loc;\n    this.withSource(\"start\", loc, printMethod.bind(this, node, parent));\n\n    if (noLineTerminator && !this._noLineTerminator) {\n      this._noLineTerminator = true;\n\n      this._printTrailingComments(node);\n\n      this._noLineTerminator = false;\n    } else {\n      this._printTrailingComments(node);\n    }\n\n    if (shouldPrintParens) this.tokenChar(41);\n\n    this._printStack.pop();\n\n    format.concise = oldConcise;\n    this._insideAux = oldInAux;\n  }\n\n  _maybeAddAuxComment(enteredPositionlessNode) {\n    if (enteredPositionlessNode) this._printAuxBeforeComment();\n    if (!this._insideAux) this._printAuxAfterComment();\n  }\n\n  _printAuxBeforeComment() {\n    if (this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = true;\n    const comment = this.format.auxiliaryCommentBefore;\n\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment\n      });\n    }\n  }\n\n  _printAuxAfterComment() {\n    if (!this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = false;\n    const comment = this.format.auxiliaryCommentAfter;\n\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment\n      });\n    }\n  }\n\n  getPossibleRaw(node) {\n    const extra = node.extra;\n\n    if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {\n      return extra.raw;\n    }\n  }\n\n  printJoin(nodes, parent, opts = {}) {\n    if (!(nodes != null && nodes.length)) return;\n    if (opts.indent) this.indent();\n    const newlineOpts = {\n      addNewlines: opts.addNewlines\n    };\n    const len = nodes.length;\n\n    for (let i = 0; i < len; i++) {\n      const node = nodes[i];\n      if (!node) continue;\n      if (opts.statement) this._printNewline(true, node, parent, newlineOpts);\n      this.print(node, parent);\n\n      if (opts.iterator) {\n        opts.iterator(node, i);\n      }\n\n      if (opts.separator && i < len - 1) {\n        opts.separator.call(this);\n      }\n\n      if (opts.statement) this._printNewline(false, node, parent, newlineOpts);\n    }\n\n    if (opts.indent) this.dedent();\n  }\n\n  printAndIndentOnComments(node, parent) {\n    const indent = node.leadingComments && node.leadingComments.length > 0;\n    if (indent) this.indent();\n    this.print(node, parent);\n    if (indent) this.dedent();\n  }\n\n  printBlock(parent) {\n    const node = parent.body;\n\n    if (node.type !== \"EmptyStatement\") {\n      this.space();\n    }\n\n    this.print(node, parent);\n  }\n\n  _printTrailingComments(node) {\n    this._printComments(this._getComments(false, node));\n  }\n\n  _printLeadingComments(node) {\n    this._printComments(this._getComments(true, node), true);\n  }\n\n  printInnerComments(node, indent = true) {\n    var _node$innerComments;\n\n    if (!((_node$innerComments = node.innerComments) != null && _node$innerComments.length)) return;\n    if (indent) this.indent();\n\n    this._printComments(node.innerComments);\n\n    if (indent) this.dedent();\n  }\n\n  printSequence(nodes, parent, opts = {}) {\n    opts.statement = true;\n    return this.printJoin(nodes, parent, opts);\n  }\n\n  printList(items, parent, opts = {}) {\n    if (opts.separator == null) {\n      opts.separator = commaSeparator;\n    }\n\n    return this.printJoin(items, parent, opts);\n  }\n\n  _printNewline(leading, node, parent, opts) {\n    if (this.format.retainLines || this.format.compact) return;\n\n    if (this.format.concise) {\n      this.space();\n      return;\n    }\n\n    let lines = 0;\n\n    if (this._buf.hasContent()) {\n      if (!leading) lines++;\n      if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;\n      const needs = leading ? needsWhitespaceBefore : needsWhitespaceAfter;\n      if (needs(node, parent)) lines++;\n    }\n\n    this.newline(Math.min(2, lines));\n  }\n\n  _getComments(leading, node) {\n    return node && (leading ? node.leadingComments : node.trailingComments) || null;\n  }\n\n  _printComment(comment, skipNewLines) {\n    if (comment.ignore) return;\n    if (this._printedComments.has(comment)) return;\n    if (!this.format.shouldPrintComment(comment.value)) return;\n\n    this._printedComments.add(comment);\n\n    const isBlockComment = comment.type === \"CommentBlock\";\n    const printNewLines = isBlockComment && !skipNewLines && !this._noLineTerminator;\n    if (printNewLines && this._buf.hasContent()) this.newline(1);\n    const lastCharCode = this.getLastChar();\n\n    if (lastCharCode !== 91 && lastCharCode !== 123) {\n      this.space();\n    }\n\n    let val;\n    let maybeNewline = false;\n\n    if (isBlockComment) {\n      val = `/*${comment.value}*/`;\n\n      if (this.format.indent.adjustMultilineComment) {\n        var _comment$loc;\n\n        const offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;\n\n        if (offset) {\n          const newlineRegex = new RegExp(\"\\\\n\\\\s{1,\" + offset + \"}\", \"g\");\n          val = val.replace(newlineRegex, \"\\n\");\n        }\n\n        const indentSize = Math.max(this._getIndent(), this.format.retainLines ? 0 : this._buf.getCurrentColumn());\n        val = val.replace(/\\n(?!$)/g, `\\n${\" \".repeat(indentSize)}`);\n        maybeNewline = true;\n      }\n    } else if (!this._noLineTerminator) {\n      val = `//${comment.value}\\n`;\n      maybeNewline = true;\n    } else {\n      val = `/*${comment.value}*/`;\n    }\n\n    if (this.endsWith(47)) this._space();\n    this.withSource(\"start\", comment.loc, this._append.bind(this, val, maybeNewline));\n    if (printNewLines) this.newline(1);\n  }\n\n  _printComments(comments, inlinePureAnnotation) {\n    if (!(comments != null && comments.length)) return;\n\n    if (inlinePureAnnotation && comments.length === 1 && PURE_ANNOTATION_RE.test(comments[0].value)) {\n      this._printComment(comments[0], this._buf.hasContent() && !this.endsWith(10));\n    } else {\n      for (const comment of comments) {\n        this._printComment(comment);\n      }\n    }\n  }\n\n  printAssertions(node) {\n    var _node$assertions;\n\n    if ((_node$assertions = node.assertions) != null && _node$assertions.length) {\n      this.space();\n      this.word(\"assert\");\n      this.space();\n      this.tokenChar(123);\n      this.space();\n      this.printList(node.assertions, node);\n      this.space();\n      this.tokenChar(125);\n    }\n  }\n\n}\n\nObject.assign(Printer.prototype, generatorFunctions);\n{\n  Printer.prototype.Noop = function Noop() {};\n}\nvar _default = Printer;\nexports.default = _default;\n\nfunction commaSeparator() {\n  this.tokenChar(44);\n  this.space();\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction SourcePos() {\n  return {\n    identifierName: undefined,\n    line: undefined,\n    column: undefined,\n    filename: undefined\n  };\n}\n\nclass Buffer {\n  constructor(map) {\n    this._map = null;\n    this._buf = \"\";\n    this._str = \"\";\n    this._appendCount = 0;\n    this._last = 0;\n    this._queue = [];\n    this._queueCursor = 0;\n    this._position = {\n      line: 1,\n      column: 0\n    };\n    this._sourcePosition = SourcePos();\n    this._disallowedPop = {\n      identifierName: undefined,\n      line: undefined,\n      column: undefined,\n      filename: undefined,\n      objectReusable: true\n    };\n    this._map = map;\n\n    this._allocQueue();\n  }\n\n  _allocQueue() {\n    const queue = this._queue;\n\n    for (let i = 0; i < 16; i++) {\n      queue.push({\n        char: 0,\n        repeat: 1,\n        line: undefined,\n        column: undefined,\n        identifierName: undefined,\n        filename: \"\"\n      });\n    }\n  }\n\n  _pushQueue(char, repeat, line, column, identifierName, filename) {\n    const cursor = this._queueCursor;\n\n    if (cursor === this._queue.length) {\n      this._allocQueue();\n    }\n\n    const item = this._queue[cursor];\n    item.char = char;\n    item.repeat = repeat;\n    item.line = line;\n    item.column = column;\n    item.identifierName = identifierName;\n    item.filename = filename;\n    this._queueCursor++;\n  }\n\n  _popQueue() {\n    if (this._queueCursor === 0) {\n      throw new Error(\"Cannot pop from empty queue\");\n    }\n\n    return this._queue[--this._queueCursor];\n  }\n\n  get() {\n    this._flush();\n\n    const map = this._map;\n    const result = {\n      code: (this._buf + this._str).trimRight(),\n      decodedMap: map == null ? void 0 : map.getDecoded(),\n\n      get map() {\n        const resultMap = map ? map.get() : null;\n        result.map = resultMap;\n        return resultMap;\n      },\n\n      set map(value) {\n        Object.defineProperty(result, \"map\", {\n          value,\n          writable: true\n        });\n      },\n\n      get rawMappings() {\n        const mappings = map == null ? void 0 : map.getRawMappings();\n        result.rawMappings = mappings;\n        return mappings;\n      },\n\n      set rawMappings(value) {\n        Object.defineProperty(result, \"rawMappings\", {\n          value,\n          writable: true\n        });\n      }\n\n    };\n    return result;\n  }\n\n  append(str, maybeNewline) {\n    this._flush();\n\n    this._append(str, this._sourcePosition, maybeNewline);\n  }\n\n  appendChar(char) {\n    this._flush();\n\n    this._appendChar(char, 1, this._sourcePosition);\n  }\n\n  queue(char) {\n    if (char === 10) {\n      while (this._queueCursor !== 0) {\n        const char = this._queue[this._queueCursor - 1].char;\n\n        if (char !== 32 && char !== 9) {\n          break;\n        }\n\n        this._queueCursor--;\n      }\n    }\n\n    const sourcePosition = this._sourcePosition;\n\n    this._pushQueue(char, 1, sourcePosition.line, sourcePosition.column, sourcePosition.identifierName, sourcePosition.filename);\n  }\n\n  queueIndentation(char, repeat) {\n    this._pushQueue(char, repeat, undefined, undefined, undefined, undefined);\n  }\n\n  _flush() {\n    const queueCursor = this._queueCursor;\n    const queue = this._queue;\n\n    for (let i = 0; i < queueCursor; i++) {\n      const item = queue[i];\n\n      this._appendChar(item.char, item.repeat, item);\n    }\n\n    this._queueCursor = 0;\n  }\n\n  _appendChar(char, repeat, sourcePos) {\n    this._last = char;\n    this._str += repeat > 1 ? String.fromCharCode(char).repeat(repeat) : String.fromCharCode(char);\n\n    if (char !== 10) {\n      this._mark(sourcePos.line, sourcePos.column, sourcePos.identifierName, sourcePos.filename);\n\n      this._position.column += repeat;\n    } else {\n      this._position.line++;\n      this._position.column = 0;\n    }\n  }\n\n  _append(str, sourcePos, maybeNewline) {\n    const len = str.length;\n    this._last = str.charCodeAt(len - 1);\n\n    if (++this._appendCount > 4096) {\n      +this._str;\n      this._buf += this._str;\n      this._str = str;\n      this._appendCount = 0;\n    } else {\n      this._str += str;\n    }\n\n    if (!maybeNewline && !this._map) {\n      this._position.column += len;\n      return;\n    }\n\n    const {\n      column,\n      identifierName,\n      filename\n    } = sourcePos;\n    let line = sourcePos.line;\n    let i = str.indexOf(\"\\n\");\n    let last = 0;\n\n    if (i !== 0) {\n      this._mark(line, column, identifierName, filename);\n    }\n\n    while (i !== -1) {\n      this._position.line++;\n      this._position.column = 0;\n      last = i + 1;\n\n      if (last < str.length) {\n        this._mark(++line, 0, identifierName, filename);\n      }\n\n      i = str.indexOf(\"\\n\", last);\n    }\n\n    this._position.column += str.length - last;\n  }\n\n  _mark(line, column, identifierName, filename) {\n    var _this$_map;\n\n    (_this$_map = this._map) == null ? void 0 : _this$_map.mark(this._position, line, column, identifierName, filename);\n  }\n\n  removeTrailingNewline() {\n    const queueCursor = this._queueCursor;\n\n    if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 10) {\n      this._queueCursor--;\n    }\n  }\n\n  removeLastSemicolon() {\n    const queueCursor = this._queueCursor;\n\n    if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 59) {\n      this._queueCursor--;\n    }\n  }\n\n  getLastChar() {\n    const queueCursor = this._queueCursor;\n    return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;\n  }\n\n  endsWithCharAndNewline() {\n    const queue = this._queue;\n    const queueCursor = this._queueCursor;\n\n    if (queueCursor !== 0) {\n      const lastCp = queue[queueCursor - 1].char;\n      if (lastCp !== 10) return;\n\n      if (queueCursor > 1) {\n        return queue[queueCursor - 2].char;\n      } else {\n        return this._last;\n      }\n    }\n  }\n\n  hasContent() {\n    return this._queueCursor !== 0 || !!this._last;\n  }\n\n  exactSource(loc, cb) {\n    if (!this._map) return cb();\n    this.source(\"start\", loc);\n    cb();\n    this.source(\"end\", loc);\n\n    this._disallowPop(\"start\", loc);\n  }\n\n  source(prop, loc) {\n    if (!loc) return;\n\n    this._normalizePosition(prop, loc, this._sourcePosition);\n  }\n\n  withSource(prop, loc, cb) {\n    if (!this._map) return cb();\n    const originalLine = this._sourcePosition.line;\n    const originalColumn = this._sourcePosition.column;\n    const originalFilename = this._sourcePosition.filename;\n    const originalIdentifierName = this._sourcePosition.identifierName;\n    this.source(prop, loc);\n    cb();\n\n    if (this._disallowedPop.objectReusable || this._disallowedPop.line !== originalLine || this._disallowedPop.column !== originalColumn || this._disallowedPop.filename !== originalFilename) {\n      this._sourcePosition.line = originalLine;\n      this._sourcePosition.column = originalColumn;\n      this._sourcePosition.filename = originalFilename;\n      this._sourcePosition.identifierName = originalIdentifierName;\n      this._disallowedPop.objectReusable = true;\n    }\n  }\n\n  _disallowPop(prop, loc) {\n    if (!loc) return;\n    const disallowedPop = this._disallowedPop;\n\n    this._normalizePosition(prop, loc, disallowedPop);\n\n    disallowedPop.objectReusable = false;\n  }\n\n  _normalizePosition(prop, loc, targetObj) {\n    const pos = loc[prop];\n    targetObj.identifierName = prop === \"start\" && loc.identifierName || undefined;\n\n    if (pos) {\n      targetObj.line = pos.line;\n      targetObj.column = pos.column;\n      targetObj.filename = loc.filename;\n    } else {\n      targetObj.line = null;\n      targetObj.column = null;\n      targetObj.filename = null;\n    }\n  }\n\n  getCurrentColumn() {\n    const queue = this._queue;\n    let lastIndex = -1;\n    let len = 0;\n\n    for (let i = 0; i < this._queueCursor; i++) {\n      const item = queue[i];\n\n      if (item.char === 10) {\n        lastIndex = i;\n        len += item.repeat;\n      }\n    }\n\n    return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;\n  }\n\n  getCurrentLine() {\n    let count = 0;\n    const queue = this._queue;\n\n    for (let i = 0; i < this._queueCursor; i++) {\n      if (queue[i].char === 10) {\n        count++;\n      }\n    }\n\n    return this._position.line + count;\n  }\n\n}\n\nexports.default = Buffer;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.needsParens = needsParens;\nexports.needsWhitespace = needsWhitespace;\nexports.needsWhitespaceAfter = needsWhitespaceAfter;\nexports.needsWhitespaceBefore = needsWhitespaceBefore;\n\nvar whitespace = require(\"./whitespace\");\n\nvar parens = require(\"./parentheses\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  FLIPPED_ALIAS_KEYS,\n  isCallExpression,\n  isExpressionStatement,\n  isMemberExpression,\n  isNewExpression\n} = _t;\n\nfunction expandAliases(obj) {\n  const newObj = {};\n\n  function add(type, func) {\n    const fn = newObj[type];\n    newObj[type] = fn ? function (node, parent, stack) {\n      const result = fn(node, parent, stack);\n      return result == null ? func(node, parent, stack) : result;\n    } : func;\n  }\n\n  for (const type of Object.keys(obj)) {\n    const aliases = FLIPPED_ALIAS_KEYS[type];\n\n    if (aliases) {\n      for (const alias of aliases) {\n        add(alias, obj[type]);\n      }\n    } else {\n      add(type, obj[type]);\n    }\n  }\n\n  return newObj;\n}\n\nconst expandedParens = expandAliases(parens);\nconst expandedWhitespaceNodes = expandAliases(whitespace.nodes);\n\nfunction find(obj, node, parent, printStack) {\n  const fn = obj[node.type];\n  return fn ? fn(node, parent, printStack) : null;\n}\n\nfunction isOrHasCallExpression(node) {\n  if (isCallExpression(node)) {\n    return true;\n  }\n\n  return isMemberExpression(node) && isOrHasCallExpression(node.object);\n}\n\nfunction needsWhitespace(node, parent, type) {\n  if (!node) return false;\n\n  if (isExpressionStatement(node)) {\n    node = node.expression;\n  }\n\n  const flag = find(expandedWhitespaceNodes, node, parent);\n\n  if (typeof flag === \"number\") {\n    return (flag & type) !== 0;\n  }\n\n  return false;\n}\n\nfunction needsWhitespaceBefore(node, parent) {\n  return needsWhitespace(node, parent, 1);\n}\n\nfunction needsWhitespaceAfter(node, parent) {\n  return needsWhitespace(node, parent, 2);\n}\n\nfunction needsParens(node, parent, printStack) {\n  if (!parent) return false;\n\n  if (isNewExpression(parent) && parent.callee === node) {\n    if (isOrHasCallExpression(node)) return true;\n  }\n\n  return find(expandedParens, node, parent, printStack);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.nodes = void 0;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  FLIPPED_ALIAS_KEYS,\n  isArrayExpression,\n  isAssignmentExpression,\n  isBinary,\n  isBlockStatement,\n  isCallExpression,\n  isFunction,\n  isIdentifier,\n  isLiteral,\n  isMemberExpression,\n  isObjectExpression,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isStringLiteral\n} = _t;\n\nfunction crawlInternal(node, state) {\n  if (!node) return state;\n\n  if (isMemberExpression(node) || isOptionalMemberExpression(node)) {\n    crawlInternal(node.object, state);\n    if (node.computed) crawlInternal(node.property, state);\n  } else if (isBinary(node) || isAssignmentExpression(node)) {\n    crawlInternal(node.left, state);\n    crawlInternal(node.right, state);\n  } else if (isCallExpression(node) || isOptionalCallExpression(node)) {\n    state.hasCall = true;\n    crawlInternal(node.callee, state);\n  } else if (isFunction(node)) {\n    state.hasFunction = true;\n  } else if (isIdentifier(node)) {\n    state.hasHelper = state.hasHelper || node.callee && isHelper(node.callee);\n  }\n\n  return state;\n}\n\nfunction crawl(node) {\n  return crawlInternal(node, {\n    hasCall: false,\n    hasFunction: false,\n    hasHelper: false\n  });\n}\n\nfunction isHelper(node) {\n  if (!node) return false;\n\n  if (isMemberExpression(node)) {\n    return isHelper(node.object) || isHelper(node.property);\n  } else if (isIdentifier(node)) {\n    return node.name === \"require\" || node.name.charCodeAt(0) === 95;\n  } else if (isCallExpression(node)) {\n    return isHelper(node.callee);\n  } else if (isBinary(node) || isAssignmentExpression(node)) {\n    return isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);\n  } else {\n    return false;\n  }\n}\n\nfunction isType(node) {\n  return isLiteral(node) || isObjectExpression(node) || isArrayExpression(node) || isIdentifier(node) || isMemberExpression(node);\n}\n\nconst nodes = {\n  AssignmentExpression(node) {\n    const state = crawl(node.right);\n\n    if (state.hasCall && state.hasHelper || state.hasFunction) {\n      return state.hasFunction ? 1 | 2 : 2;\n    }\n  },\n\n  SwitchCase(node, parent) {\n    return (!!node.consequent.length || parent.cases[0] === node ? 1 : 0) | (!node.consequent.length && parent.cases[parent.cases.length - 1] === node ? 2 : 0);\n  },\n\n  LogicalExpression(node) {\n    if (isFunction(node.left) || isFunction(node.right)) {\n      return 2;\n    }\n  },\n\n  Literal(node) {\n    if (isStringLiteral(node) && node.value === \"use strict\") {\n      return 2;\n    }\n  },\n\n  CallExpression(node) {\n    if (isFunction(node.callee) || isHelper(node)) {\n      return 1 | 2;\n    }\n  },\n\n  OptionalCallExpression(node) {\n    if (isFunction(node.callee)) {\n      return 1 | 2;\n    }\n  },\n\n  VariableDeclaration(node) {\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n      let enabled = isHelper(declar.id) && !isType(declar.init);\n\n      if (!enabled && declar.init) {\n        const state = crawl(declar.init);\n        enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;\n      }\n\n      if (enabled) {\n        return 1 | 2;\n      }\n    }\n  },\n\n  IfStatement(node) {\n    if (isBlockStatement(node.consequent)) {\n      return 1 | 2;\n    }\n  }\n\n};\nexports.nodes = nodes;\n\nnodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function (node, parent) {\n  if (parent.properties[0] === node) {\n    return 1;\n  }\n};\n\nnodes.ObjectTypeCallProperty = function (node, parent) {\n  var _parent$properties;\n\n  if (parent.callProperties[0] === node && !((_parent$properties = parent.properties) != null && _parent$properties.length)) {\n    return 1;\n  }\n};\n\nnodes.ObjectTypeIndexer = function (node, parent) {\n  var _parent$properties2, _parent$callPropertie;\n\n  if (parent.indexers[0] === node && !((_parent$properties2 = parent.properties) != null && _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) != null && _parent$callPropertie.length)) {\n    return 1;\n  }\n};\n\nnodes.ObjectTypeInternalSlot = function (node, parent) {\n  var _parent$properties3, _parent$callPropertie2, _parent$indexers;\n\n  if (parent.internalSlots[0] === node && !((_parent$properties3 = parent.properties) != null && _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) != null && _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) != null && _parent$indexers.length)) {\n    return 1;\n  }\n};\n\n[[\"Function\", true], [\"Class\", true], [\"Loop\", true], [\"LabeledStatement\", true], [\"SwitchStatement\", true], [\"TryStatement\", true]].forEach(function ([type, amounts]) {\n  [type].concat(FLIPPED_ALIAS_KEYS[type] || []).forEach(function (type) {\n    const ret = amounts ? 1 | 2 : 0;\n\n    nodes[type] = () => ret;\n  });\n});","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.Binary = Binary;\nexports.BinaryExpression = BinaryExpression;\nexports.ClassExpression = ClassExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.DoExpression = DoExpression;\nexports.FunctionExpression = FunctionExpression;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.Identifier = Identifier;\nexports.LogicalExpression = LogicalExpression;\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nexports.ObjectExpression = ObjectExpression;\nexports.OptionalIndexedAccessType = OptionalIndexedAccessType;\nexports.OptionalCallExpression = exports.OptionalMemberExpression = OptionalMemberExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.TSAsExpression = TSAsExpression;\nexports.TSInferType = TSInferType;\nexports.TSInstantiationExpression = TSInstantiationExpression;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSIntersectionType = exports.TSUnionType = TSUnionType;\nexports.UnaryLike = UnaryLike;\nexports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.UpdateExpression = UpdateExpression;\nexports.AwaitExpression = exports.YieldExpression = YieldExpression;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  isArrayTypeAnnotation,\n  isArrowFunctionExpression,\n  isAssignmentExpression,\n  isAwaitExpression,\n  isBinary,\n  isBinaryExpression,\n  isUpdateExpression,\n  isCallExpression,\n  isClass,\n  isClassExpression,\n  isConditional,\n  isConditionalExpression,\n  isExportDeclaration,\n  isExportDefaultDeclaration,\n  isExpressionStatement,\n  isFor,\n  isForInStatement,\n  isForOfStatement,\n  isForStatement,\n  isFunctionExpression,\n  isIfStatement,\n  isIndexedAccessType,\n  isIntersectionTypeAnnotation,\n  isLogicalExpression,\n  isMemberExpression,\n  isNewExpression,\n  isNullableTypeAnnotation,\n  isObjectPattern,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isReturnStatement,\n  isSequenceExpression,\n  isSwitchStatement,\n  isTSArrayType,\n  isTSAsExpression,\n  isTSInstantiationExpression,\n  isTSIntersectionType,\n  isTSNonNullExpression,\n  isTSOptionalType,\n  isTSRestType,\n  isTSTypeAssertion,\n  isTSUnionType,\n  isTaggedTemplateExpression,\n  isThrowStatement,\n  isTypeAnnotation,\n  isUnaryLike,\n  isUnionTypeAnnotation,\n  isVariableDeclarator,\n  isWhileStatement,\n  isYieldExpression\n} = _t;\nconst PRECEDENCE = {\n  \"||\": 0,\n  \"??\": 0,\n  \"|>\": 0,\n  \"&&\": 1,\n  \"|\": 2,\n  \"^\": 3,\n  \"&\": 4,\n  \"==\": 5,\n  \"===\": 5,\n  \"!=\": 5,\n  \"!==\": 5,\n  \"<\": 6,\n  \">\": 6,\n  \"<=\": 6,\n  \">=\": 6,\n  in: 6,\n  instanceof: 6,\n  \">>\": 7,\n  \"<<\": 7,\n  \">>>\": 7,\n  \"+\": 8,\n  \"-\": 8,\n  \"*\": 9,\n  \"/\": 9,\n  \"%\": 9,\n  \"**\": 10\n};\n\nconst isClassExtendsClause = (node, parent) => isClass(parent, {\n  superClass: node\n});\n\nconst hasPostfixPart = (node, parent) => (isMemberExpression(parent) || isOptionalMemberExpression(parent)) && parent.object === node || (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent)) && parent.callee === node || isTaggedTemplateExpression(parent) && parent.tag === node || isTSNonNullExpression(parent);\n\nfunction NullableTypeAnnotation(node, parent) {\n  return isArrayTypeAnnotation(parent);\n}\n\nfunction FunctionTypeAnnotation(node, parent, printStack) {\n  if (printStack.length < 3) return;\n  return isUnionTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isArrayTypeAnnotation(parent) || isTypeAnnotation(parent) && isArrowFunctionExpression(printStack[printStack.length - 3]);\n}\n\nfunction UpdateExpression(node, parent) {\n  return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);\n}\n\nfunction ObjectExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, 1 | 2);\n}\n\nfunction DoExpression(node, parent, printStack) {\n  return !node.async && isFirstInContext(printStack, 1);\n}\n\nfunction Binary(node, parent) {\n  if (node.operator === \"**\" && isBinaryExpression(parent, {\n    operator: \"**\"\n  })) {\n    return parent.left === node;\n  }\n\n  if (isClassExtendsClause(node, parent)) {\n    return true;\n  }\n\n  if (hasPostfixPart(node, parent) || isUnaryLike(parent) || isAwaitExpression(parent)) {\n    return true;\n  }\n\n  if (isBinary(parent)) {\n    const parentOp = parent.operator;\n    const parentPos = PRECEDENCE[parentOp];\n    const nodeOp = node.operator;\n    const nodePos = PRECEDENCE[nodeOp];\n\n    if (parentPos === nodePos && parent.right === node && !isLogicalExpression(parent) || parentPos > nodePos) {\n      return true;\n    }\n  }\n}\n\nfunction UnionTypeAnnotation(node, parent) {\n  return isArrayTypeAnnotation(parent) || isNullableTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isUnionTypeAnnotation(parent);\n}\n\nfunction OptionalIndexedAccessType(node, parent) {\n  return isIndexedAccessType(parent, {\n    objectType: node\n  });\n}\n\nfunction TSAsExpression() {\n  return true;\n}\n\nfunction TSTypeAssertion() {\n  return true;\n}\n\nfunction TSUnionType(node, parent) {\n  return isTSArrayType(parent) || isTSOptionalType(parent) || isTSIntersectionType(parent) || isTSUnionType(parent) || isTSRestType(parent);\n}\n\nfunction TSInferType(node, parent) {\n  return isTSArrayType(parent) || isTSOptionalType(parent);\n}\n\nfunction TSInstantiationExpression(node, parent) {\n  return (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent) || isTSInstantiationExpression(parent)) && !!parent.typeParameters;\n}\n\nfunction BinaryExpression(node, parent) {\n  return node.operator === \"in\" && (isVariableDeclarator(parent) || isFor(parent));\n}\n\nfunction SequenceExpression(node, parent) {\n  if (isForStatement(parent) || isThrowStatement(parent) || isReturnStatement(parent) || isIfStatement(parent) && parent.test === node || isWhileStatement(parent) && parent.test === node || isForInStatement(parent) && parent.right === node || isSwitchStatement(parent) && parent.discriminant === node || isExpressionStatement(parent) && parent.expression === node) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction YieldExpression(node, parent) {\n  return isBinary(parent) || isUnaryLike(parent) || hasPostfixPart(node, parent) || isAwaitExpression(parent) && isYieldExpression(node) || isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);\n}\n\nfunction ClassExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, 1 | 4);\n}\n\nfunction UnaryLike(node, parent) {\n  return hasPostfixPart(node, parent) || isBinaryExpression(parent, {\n    operator: \"**\",\n    left: node\n  }) || isClassExtendsClause(node, parent);\n}\n\nfunction FunctionExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, 1 | 4);\n}\n\nfunction ArrowFunctionExpression(node, parent) {\n  return isExportDeclaration(parent) || ConditionalExpression(node, parent);\n}\n\nfunction ConditionalExpression(node, parent) {\n  if (isUnaryLike(parent) || isBinary(parent) || isConditionalExpression(parent, {\n    test: node\n  }) || isAwaitExpression(parent) || isTSTypeAssertion(parent) || isTSAsExpression(parent)) {\n    return true;\n  }\n\n  return UnaryLike(node, parent);\n}\n\nfunction OptionalMemberExpression(node, parent) {\n  return isCallExpression(parent, {\n    callee: node\n  }) || isMemberExpression(parent, {\n    object: node\n  });\n}\n\nfunction AssignmentExpression(node, parent) {\n  if (isObjectPattern(node.left)) {\n    return true;\n  } else {\n    return ConditionalExpression(node, parent);\n  }\n}\n\nfunction LogicalExpression(node, parent) {\n  switch (node.operator) {\n    case \"||\":\n      if (!isLogicalExpression(parent)) return false;\n      return parent.operator === \"??\" || parent.operator === \"&&\";\n\n    case \"&&\":\n      return isLogicalExpression(parent, {\n        operator: \"??\"\n      });\n\n    case \"??\":\n      return isLogicalExpression(parent) && parent.operator !== \"??\";\n  }\n}\n\nfunction Identifier(node, parent, printStack) {\n  var _node$extra;\n\n  if ((_node$extra = node.extra) != null && _node$extra.parenthesized && isAssignmentExpression(parent, {\n    left: node\n  }) && (isFunctionExpression(parent.right) || isClassExpression(parent.right)) && parent.right.id == null) {\n    return true;\n  }\n\n  if (node.name === \"let\") {\n    const isFollowedByBracket = isMemberExpression(parent, {\n      object: node,\n      computed: true\n    }) || isOptionalMemberExpression(parent, {\n      object: node,\n      computed: true,\n      optional: false\n    });\n    return isFirstInContext(printStack, isFollowedByBracket ? 1 | 8 | 16 | 32 : 32);\n  }\n\n  return node.name === \"async\" && isForOfStatement(parent) && node === parent.left;\n}\n\nfunction isFirstInContext(printStack, checkParam) {\n  const expressionStatement = checkParam & 1;\n  const arrowBody = checkParam & 2;\n  const exportDefault = checkParam & 4;\n  const forHead = checkParam & 8;\n  const forInHead = checkParam & 16;\n  const forOfHead = checkParam & 32;\n  let i = printStack.length - 1;\n  if (i <= 0) return;\n  let node = printStack[i];\n  i--;\n  let parent = printStack[i];\n\n  while (i >= 0) {\n    if (expressionStatement && isExpressionStatement(parent, {\n      expression: node\n    }) || exportDefault && isExportDefaultDeclaration(parent, {\n      declaration: node\n    }) || arrowBody && isArrowFunctionExpression(parent, {\n      body: node\n    }) || forHead && isForStatement(parent, {\n      init: node\n    }) || forInHead && isForInStatement(parent, {\n      left: node\n    }) || forOfHead && isForOfStatement(parent, {\n      left: node\n    })) {\n      return true;\n    }\n\n    if (i > 0 && (hasPostfixPart(node, parent) && !isNewExpression(parent) || isSequenceExpression(parent) && parent.expressions[0] === node || isUpdateExpression(parent) && !parent.prefix || isConditional(parent, {\n      test: node\n    }) || isBinary(parent, {\n      left: node\n    }) || isAssignmentExpression(parent, {\n      left: node\n    }))) {\n      node = parent;\n      i--;\n      parent = printStack[i];\n    } else {\n      return false;\n    }\n  }\n\n  return false;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _templateLiterals = require(\"./template-literals\");\n\nObject.keys(_templateLiterals).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _templateLiterals[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _templateLiterals[key];\n    }\n  });\n});\n\nvar _expressions = require(\"./expressions\");\n\nObject.keys(_expressions).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _expressions[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _expressions[key];\n    }\n  });\n});\n\nvar _statements = require(\"./statements\");\n\nObject.keys(_statements).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _statements[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _statements[key];\n    }\n  });\n});\n\nvar _classes = require(\"./classes\");\n\nObject.keys(_classes).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _classes[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _classes[key];\n    }\n  });\n});\n\nvar _methods = require(\"./methods\");\n\nObject.keys(_methods).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _methods[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _methods[key];\n    }\n  });\n});\n\nvar _modules = require(\"./modules\");\n\nObject.keys(_modules).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _modules[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _modules[key];\n    }\n  });\n});\n\nvar _types = require(\"./types\");\n\nObject.keys(_types).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _types[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _types[key];\n    }\n  });\n});\n\nvar _flow = require(\"./flow\");\n\nObject.keys(_flow).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _flow[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _flow[key];\n    }\n  });\n});\n\nvar _base = require(\"./base\");\n\nObject.keys(_base).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _base[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _base[key];\n    }\n  });\n});\n\nvar _jsx = require(\"./jsx\");\n\nObject.keys(_jsx).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _jsx[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _jsx[key];\n    }\n  });\n});\n\nvar _typescript = require(\"./typescript\");\n\nObject.keys(_typescript).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _typescript[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _typescript[key];\n    }\n  });\n});","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nexports.TemplateElement = TemplateElement;\nexports.TemplateLiteral = TemplateLiteral;\n\nfunction TaggedTemplateExpression(node) {\n  this.print(node.tag, node);\n  this.print(node.typeParameters, node);\n  this.print(node.quasi, node);\n}\n\nfunction TemplateElement(node, parent) {\n  const isFirst = parent.quasis[0] === node;\n  const isLast = parent.quasis[parent.quasis.length - 1] === node;\n  const value = (isFirst ? \"`\" : \"}\") + node.value.raw + (isLast ? \"`\" : \"${\");\n  this.token(value, true);\n}\n\nfunction TemplateLiteral(node) {\n  const quasis = node.quasis;\n\n  for (let i = 0; i < quasis.length; i++) {\n    this.print(quasis[i], node);\n\n    if (i + 1 < quasis.length) {\n      this.print(node.expressions[i], node);\n    }\n  }\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LogicalExpression = exports.BinaryExpression = exports.AssignmentExpression = AssignmentExpression;\nexports.AssignmentPattern = AssignmentPattern;\nexports.AwaitExpression = AwaitExpression;\nexports.BindExpression = BindExpression;\nexports.CallExpression = CallExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.Decorator = Decorator;\nexports.DoExpression = DoExpression;\nexports.EmptyStatement = EmptyStatement;\nexports.ExpressionStatement = ExpressionStatement;\nexports.Import = Import;\nexports.MemberExpression = MemberExpression;\nexports.MetaProperty = MetaProperty;\nexports.ModuleExpression = ModuleExpression;\nexports.NewExpression = NewExpression;\nexports.OptionalCallExpression = OptionalCallExpression;\nexports.OptionalMemberExpression = OptionalMemberExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.PrivateName = PrivateName;\nexports.SequenceExpression = SequenceExpression;\nexports.Super = Super;\nexports.ThisExpression = ThisExpression;\nexports.UnaryExpression = UnaryExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.V8IntrinsicIdentifier = V8IntrinsicIdentifier;\nexports.YieldExpression = YieldExpression;\n\nvar _t = require(\"@babel/types\");\n\nvar n = require(\"../node\");\n\nconst {\n  isCallExpression,\n  isLiteral,\n  isMemberExpression,\n  isNewExpression\n} = _t;\n\nfunction UnaryExpression(node) {\n  if (node.operator === \"void\" || node.operator === \"delete\" || node.operator === \"typeof\" || node.operator === \"throw\") {\n    this.word(node.operator);\n    this.space();\n  } else {\n    this.token(node.operator);\n  }\n\n  this.print(node.argument, node);\n}\n\nfunction DoExpression(node) {\n  if (node.async) {\n    this.word(\"async\");\n    this.space();\n  }\n\n  this.word(\"do\");\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction ParenthesizedExpression(node) {\n  this.tokenChar(40);\n  this.print(node.expression, node);\n  this.tokenChar(41);\n}\n\nfunction UpdateExpression(node) {\n  if (node.prefix) {\n    this.token(node.operator);\n    this.print(node.argument, node);\n  } else {\n    this.printTerminatorless(node.argument, node, true);\n    this.token(node.operator);\n  }\n}\n\nfunction ConditionalExpression(node) {\n  this.print(node.test, node);\n  this.space();\n  this.tokenChar(63);\n  this.space();\n  this.print(node.consequent, node);\n  this.space();\n  this.tokenChar(58);\n  this.space();\n  this.print(node.alternate, node);\n}\n\nfunction NewExpression(node, parent) {\n  this.word(\"new\");\n  this.space();\n  this.print(node.callee, node);\n\n  if (this.format.minified && node.arguments.length === 0 && !node.optional && !isCallExpression(parent, {\n    callee: node\n  }) && !isMemberExpression(parent) && !isNewExpression(parent)) {\n    return;\n  }\n\n  this.print(node.typeArguments, node);\n  this.print(node.typeParameters, node);\n\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n\n  this.tokenChar(40);\n  this.printList(node.arguments, node);\n  this.tokenChar(41);\n}\n\nfunction SequenceExpression(node) {\n  this.printList(node.expressions, node);\n}\n\nfunction ThisExpression() {\n  this.word(\"this\");\n}\n\nfunction Super() {\n  this.word(\"super\");\n}\n\nfunction isDecoratorMemberExpression(node) {\n  switch (node.type) {\n    case \"Identifier\":\n      return true;\n\n    case \"MemberExpression\":\n      return !node.computed && node.property.type === \"Identifier\" && isDecoratorMemberExpression(node.object);\n\n    default:\n      return false;\n  }\n}\n\nfunction shouldParenthesizeDecoratorExpression(node) {\n  if (node.type === \"CallExpression\") {\n    node = node.callee;\n  }\n\n  if (node.type === \"ParenthesizedExpression\") {\n    return false;\n  }\n\n  return !isDecoratorMemberExpression(node);\n}\n\nfunction Decorator(node) {\n  this.tokenChar(64);\n  const {\n    expression\n  } = node;\n\n  if (shouldParenthesizeDecoratorExpression(expression)) {\n    this.tokenChar(40);\n    this.print(expression, node);\n    this.tokenChar(41);\n  } else {\n    this.print(expression, node);\n  }\n\n  this.newline();\n}\n\nfunction OptionalMemberExpression(node) {\n  this.print(node.object, node);\n\n  if (!node.computed && isMemberExpression(node.property)) {\n    throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n  }\n\n  let computed = node.computed;\n\n  if (isLiteral(node.property) && typeof node.property.value === \"number\") {\n    computed = true;\n  }\n\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n\n  if (computed) {\n    this.tokenChar(91);\n    this.print(node.property, node);\n    this.tokenChar(93);\n  } else {\n    if (!node.optional) {\n      this.tokenChar(46);\n    }\n\n    this.print(node.property, node);\n  }\n}\n\nfunction OptionalCallExpression(node) {\n  this.print(node.callee, node);\n  this.print(node.typeArguments, node);\n  this.print(node.typeParameters, node);\n\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n\n  this.tokenChar(40);\n  this.printList(node.arguments, node);\n  this.tokenChar(41);\n}\n\nfunction CallExpression(node) {\n  this.print(node.callee, node);\n  this.print(node.typeArguments, node);\n  this.print(node.typeParameters, node);\n  this.tokenChar(40);\n  this.printList(node.arguments, node);\n  this.tokenChar(41);\n}\n\nfunction Import() {\n  this.word(\"import\");\n}\n\nfunction AwaitExpression(node) {\n  this.word(\"await\");\n\n  if (node.argument) {\n    this.space();\n    this.printTerminatorless(node.argument, node, false);\n  }\n}\n\nfunction YieldExpression(node) {\n  this.word(\"yield\");\n\n  if (node.delegate) {\n    this.tokenChar(42);\n  }\n\n  if (node.argument) {\n    this.space();\n    this.printTerminatorless(node.argument, node, false);\n  }\n}\n\nfunction EmptyStatement() {\n  this.semicolon(true);\n}\n\nfunction ExpressionStatement(node) {\n  this.print(node.expression, node);\n  this.semicolon();\n}\n\nfunction AssignmentPattern(node) {\n  this.print(node.left, node);\n  if (node.left.optional) this.tokenChar(63);\n  this.print(node.left.typeAnnotation, node);\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(node.right, node);\n}\n\nfunction AssignmentExpression(node, parent) {\n  const parens = this.inForStatementInitCounter && node.operator === \"in\" && !n.needsParens(node, parent);\n\n  if (parens) {\n    this.tokenChar(40);\n  }\n\n  this.print(node.left, node);\n  this.space();\n\n  if (node.operator === \"in\" || node.operator === \"instanceof\") {\n    this.word(node.operator);\n  } else {\n    this.token(node.operator);\n  }\n\n  this.space();\n  this.print(node.right, node);\n\n  if (parens) {\n    this.tokenChar(41);\n  }\n}\n\nfunction BindExpression(node) {\n  this.print(node.object, node);\n  this.token(\"::\");\n  this.print(node.callee, node);\n}\n\nfunction MemberExpression(node) {\n  this.print(node.object, node);\n\n  if (!node.computed && isMemberExpression(node.property)) {\n    throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n  }\n\n  let computed = node.computed;\n\n  if (isLiteral(node.property) && typeof node.property.value === \"number\") {\n    computed = true;\n  }\n\n  if (computed) {\n    this.tokenChar(91);\n    this.print(node.property, node);\n    this.tokenChar(93);\n  } else {\n    this.tokenChar(46);\n    this.print(node.property, node);\n  }\n}\n\nfunction MetaProperty(node) {\n  this.print(node.meta, node);\n  this.tokenChar(46);\n  this.print(node.property, node);\n}\n\nfunction PrivateName(node) {\n  this.tokenChar(35);\n  this.print(node.id, node);\n}\n\nfunction V8IntrinsicIdentifier(node) {\n  this.tokenChar(37);\n  this.word(node.name);\n}\n\nfunction ModuleExpression(node) {\n  this.word(\"module\");\n  this.space();\n  this.tokenChar(123);\n\n  if (node.body.body.length === 0) {\n    this.tokenChar(125);\n  } else {\n    this.newline();\n    this.printSequence(node.body.body, node, {\n      indent: true\n    });\n    this.rightBrace();\n  }\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BreakStatement = BreakStatement;\nexports.CatchClause = CatchClause;\nexports.ContinueStatement = ContinueStatement;\nexports.DebuggerStatement = DebuggerStatement;\nexports.DoWhileStatement = DoWhileStatement;\nexports.ForOfStatement = exports.ForInStatement = void 0;\nexports.ForStatement = ForStatement;\nexports.IfStatement = IfStatement;\nexports.LabeledStatement = LabeledStatement;\nexports.ReturnStatement = ReturnStatement;\nexports.SwitchCase = SwitchCase;\nexports.SwitchStatement = SwitchStatement;\nexports.ThrowStatement = ThrowStatement;\nexports.TryStatement = TryStatement;\nexports.VariableDeclaration = VariableDeclaration;\nexports.VariableDeclarator = VariableDeclarator;\nexports.WhileStatement = WhileStatement;\nexports.WithStatement = WithStatement;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  isFor,\n  isForStatement,\n  isIfStatement,\n  isStatement\n} = _t;\n\nfunction WithStatement(node) {\n  this.word(\"with\");\n  this.space();\n  this.tokenChar(40);\n  this.print(node.object, node);\n  this.tokenChar(41);\n  this.printBlock(node);\n}\n\nfunction IfStatement(node) {\n  this.word(\"if\");\n  this.space();\n  this.tokenChar(40);\n  this.print(node.test, node);\n  this.tokenChar(41);\n  this.space();\n  const needsBlock = node.alternate && isIfStatement(getLastStatement(node.consequent));\n\n  if (needsBlock) {\n    this.tokenChar(123);\n    this.newline();\n    this.indent();\n  }\n\n  this.printAndIndentOnComments(node.consequent, node);\n\n  if (needsBlock) {\n    this.dedent();\n    this.newline();\n    this.tokenChar(125);\n  }\n\n  if (node.alternate) {\n    if (this.endsWith(125)) this.space();\n    this.word(\"else\");\n    this.space();\n    this.printAndIndentOnComments(node.alternate, node);\n  }\n}\n\nfunction getLastStatement(statement) {\n  const {\n    body\n  } = statement;\n\n  if (isStatement(body) === false) {\n    return statement;\n  }\n\n  return getLastStatement(body);\n}\n\nfunction ForStatement(node) {\n  this.word(\"for\");\n  this.space();\n  this.tokenChar(40);\n  this.inForStatementInitCounter++;\n  this.print(node.init, node);\n  this.inForStatementInitCounter--;\n  this.tokenChar(59);\n\n  if (node.test) {\n    this.space();\n    this.print(node.test, node);\n  }\n\n  this.tokenChar(59);\n\n  if (node.update) {\n    this.space();\n    this.print(node.update, node);\n  }\n\n  this.tokenChar(41);\n  this.printBlock(node);\n}\n\nfunction WhileStatement(node) {\n  this.word(\"while\");\n  this.space();\n  this.tokenChar(40);\n  this.print(node.test, node);\n  this.tokenChar(41);\n  this.printBlock(node);\n}\n\nfunction ForXStatement(node) {\n  this.word(\"for\");\n  this.space();\n  const isForOf = node.type === \"ForOfStatement\";\n\n  if (isForOf && node.await) {\n    this.word(\"await\");\n    this.space();\n  }\n\n  this.tokenChar(40);\n  this.print(node.left, node);\n  this.space();\n  this.word(isForOf ? \"of\" : \"in\");\n  this.space();\n  this.print(node.right, node);\n  this.tokenChar(41);\n  this.printBlock(node);\n}\n\nconst ForInStatement = ForXStatement;\nexports.ForInStatement = ForInStatement;\nconst ForOfStatement = ForXStatement;\nexports.ForOfStatement = ForOfStatement;\n\nfunction DoWhileStatement(node) {\n  this.word(\"do\");\n  this.space();\n  this.print(node.body, node);\n  this.space();\n  this.word(\"while\");\n  this.space();\n  this.tokenChar(40);\n  this.print(node.test, node);\n  this.tokenChar(41);\n  this.semicolon();\n}\n\nfunction printStatementAfterKeyword(printer, node, parent, isLabel) {\n  if (node) {\n    printer.space();\n    printer.printTerminatorless(node, parent, isLabel);\n  }\n\n  printer.semicolon();\n}\n\nfunction BreakStatement(node) {\n  this.word(\"break\");\n  printStatementAfterKeyword(this, node.label, node, true);\n}\n\nfunction ContinueStatement(node) {\n  this.word(\"continue\");\n  printStatementAfterKeyword(this, node.label, node, true);\n}\n\nfunction ReturnStatement(node) {\n  this.word(\"return\");\n  printStatementAfterKeyword(this, node.argument, node, false);\n}\n\nfunction ThrowStatement(node) {\n  this.word(\"throw\");\n  printStatementAfterKeyword(this, node.argument, node, false);\n}\n\nfunction LabeledStatement(node) {\n  this.print(node.label, node);\n  this.tokenChar(58);\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction TryStatement(node) {\n  this.word(\"try\");\n  this.space();\n  this.print(node.block, node);\n  this.space();\n\n  if (node.handlers) {\n    this.print(node.handlers[0], node);\n  } else {\n    this.print(node.handler, node);\n  }\n\n  if (node.finalizer) {\n    this.space();\n    this.word(\"finally\");\n    this.space();\n    this.print(node.finalizer, node);\n  }\n}\n\nfunction CatchClause(node) {\n  this.word(\"catch\");\n  this.space();\n\n  if (node.param) {\n    this.tokenChar(40);\n    this.print(node.param, node);\n    this.print(node.param.typeAnnotation, node);\n    this.tokenChar(41);\n    this.space();\n  }\n\n  this.print(node.body, node);\n}\n\nfunction SwitchStatement(node) {\n  this.word(\"switch\");\n  this.space();\n  this.tokenChar(40);\n  this.print(node.discriminant, node);\n  this.tokenChar(41);\n  this.space();\n  this.tokenChar(123);\n  this.printSequence(node.cases, node, {\n    indent: true,\n\n    addNewlines(leading, cas) {\n      if (!leading && node.cases[node.cases.length - 1] === cas) return -1;\n    }\n\n  });\n  this.tokenChar(125);\n}\n\nfunction SwitchCase(node) {\n  if (node.test) {\n    this.word(\"case\");\n    this.space();\n    this.print(node.test, node);\n    this.tokenChar(58);\n  } else {\n    this.word(\"default\");\n    this.tokenChar(58);\n  }\n\n  if (node.consequent.length) {\n    this.newline();\n    this.printSequence(node.consequent, node, {\n      indent: true\n    });\n  }\n}\n\nfunction DebuggerStatement() {\n  this.word(\"debugger\");\n  this.semicolon();\n}\n\nfunction variableDeclarationIndent() {\n  this.tokenChar(44);\n  this.newline();\n\n  if (this.endsWith(10)) {\n    for (let i = 0; i < 4; i++) this.space(true);\n  }\n}\n\nfunction constDeclarationIndent() {\n  this.tokenChar(44);\n  this.newline();\n\n  if (this.endsWith(10)) {\n    for (let i = 0; i < 6; i++) this.space(true);\n  }\n}\n\nfunction VariableDeclaration(node, parent) {\n  if (node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.word(node.kind);\n  this.space();\n  let hasInits = false;\n\n  if (!isFor(parent)) {\n    for (const declar of node.declarations) {\n      if (declar.init) {\n        hasInits = true;\n      }\n    }\n  }\n\n  let separator;\n\n  if (hasInits) {\n    separator = node.kind === \"const\" ? constDeclarationIndent : variableDeclarationIndent;\n  }\n\n  this.printList(node.declarations, node, {\n    separator\n  });\n\n  if (isFor(parent)) {\n    if (isForStatement(parent)) {\n      if (parent.init === node) return;\n    } else {\n      if (parent.left === node) return;\n    }\n  }\n\n  this.semicolon();\n}\n\nfunction VariableDeclarator(node) {\n  this.print(node.id, node);\n  if (node.definite) this.tokenChar(33);\n  this.print(node.id.typeAnnotation, node);\n\n  if (node.init) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.init, node);\n  }\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ClassAccessorProperty = ClassAccessorProperty;\nexports.ClassBody = ClassBody;\nexports.ClassExpression = exports.ClassDeclaration = ClassDeclaration;\nexports.ClassMethod = ClassMethod;\nexports.ClassPrivateMethod = ClassPrivateMethod;\nexports.ClassPrivateProperty = ClassPrivateProperty;\nexports.ClassProperty = ClassProperty;\nexports.StaticBlock = StaticBlock;\nexports._classMethodHead = _classMethodHead;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  isExportDefaultDeclaration,\n  isExportNamedDeclaration\n} = _t;\n\nfunction ClassDeclaration(node, parent) {\n  {\n    if (!this.format.decoratorsBeforeExport || !isExportDefaultDeclaration(parent) && !isExportNamedDeclaration(parent)) {\n      this.printJoin(node.decorators, node);\n    }\n  }\n\n  if (node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (node.abstract) {\n    this.word(\"abstract\");\n    this.space();\n  }\n\n  this.word(\"class\");\n  this.printInnerComments(node);\n\n  if (node.id) {\n    this.space();\n    this.print(node.id, node);\n  }\n\n  this.print(node.typeParameters, node);\n\n  if (node.superClass) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.print(node.superClass, node);\n    this.print(node.superTypeParameters, node);\n  }\n\n  if (node.implements) {\n    this.space();\n    this.word(\"implements\");\n    this.space();\n    this.printList(node.implements, node);\n  }\n\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction ClassBody(node) {\n  this.tokenChar(123);\n  this.printInnerComments(node);\n\n  if (node.body.length === 0) {\n    this.tokenChar(125);\n  } else {\n    this.newline();\n    this.indent();\n    this.printSequence(node.body, node);\n    this.dedent();\n    if (!this.endsWith(10)) this.newline();\n    this.rightBrace();\n  }\n}\n\nfunction ClassProperty(node) {\n  this.printJoin(node.decorators, node);\n  this.source(\"end\", node.key.loc);\n  this.tsPrintClassMemberModifiers(node);\n\n  if (node.computed) {\n    this.tokenChar(91);\n    this.print(node.key, node);\n    this.tokenChar(93);\n  } else {\n    this._variance(node);\n\n    this.print(node.key, node);\n  }\n\n  if (node.optional) {\n    this.tokenChar(63);\n  }\n\n  if (node.definite) {\n    this.tokenChar(33);\n  }\n\n  this.print(node.typeAnnotation, node);\n\n  if (node.value) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.value, node);\n  }\n\n  this.semicolon();\n}\n\nfunction ClassAccessorProperty(node) {\n  this.printJoin(node.decorators, node);\n  this.source(\"end\", node.key.loc);\n  this.tsPrintClassMemberModifiers(node);\n  this.word(\"accessor\");\n  this.printInnerComments(node);\n  this.space();\n\n  if (node.computed) {\n    this.tokenChar(91);\n    this.print(node.key, node);\n    this.tokenChar(93);\n  } else {\n    this._variance(node);\n\n    this.print(node.key, node);\n  }\n\n  if (node.optional) {\n    this.tokenChar(63);\n  }\n\n  if (node.definite) {\n    this.tokenChar(33);\n  }\n\n  this.print(node.typeAnnotation, node);\n\n  if (node.value) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.value, node);\n  }\n\n  this.semicolon();\n}\n\nfunction ClassPrivateProperty(node) {\n  this.printJoin(node.decorators, node);\n\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n\n  this.print(node.key, node);\n  this.print(node.typeAnnotation, node);\n\n  if (node.value) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.value, node);\n  }\n\n  this.semicolon();\n}\n\nfunction ClassMethod(node) {\n  this._classMethodHead(node);\n\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction ClassPrivateMethod(node) {\n  this._classMethodHead(node);\n\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction _classMethodHead(node) {\n  this.printJoin(node.decorators, node);\n  this.source(\"end\", node.key.loc);\n  this.tsPrintClassMemberModifiers(node);\n\n  this._methodHead(node);\n}\n\nfunction StaticBlock(node) {\n  this.word(\"static\");\n  this.space();\n  this.tokenChar(123);\n\n  if (node.body.length === 0) {\n    this.tokenChar(125);\n  } else {\n    this.newline();\n    this.printSequence(node.body, node, {\n      indent: true\n    });\n    this.rightBrace();\n  }\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\nexports.FunctionDeclaration = exports.FunctionExpression = FunctionExpression;\nexports._functionHead = _functionHead;\nexports._methodHead = _methodHead;\nexports._param = _param;\nexports._parameters = _parameters;\nexports._params = _params;\nexports._predicate = _predicate;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  isIdentifier\n} = _t;\n\nfunction _params(node) {\n  this.print(node.typeParameters, node);\n  this.tokenChar(40);\n\n  this._parameters(node.params, node);\n\n  this.tokenChar(41);\n  this.print(node.returnType, node, node.type === \"ArrowFunctionExpression\");\n}\n\nfunction _parameters(parameters, parent) {\n  for (let i = 0; i < parameters.length; i++) {\n    this._param(parameters[i], parent);\n\n    if (i < parameters.length - 1) {\n      this.tokenChar(44);\n      this.space();\n    }\n  }\n}\n\nfunction _param(parameter, parent) {\n  this.printJoin(parameter.decorators, parameter);\n  this.print(parameter, parent);\n\n  if (parameter.optional) {\n    this.tokenChar(63);\n  }\n\n  this.print(parameter.typeAnnotation, parameter);\n}\n\nfunction _methodHead(node) {\n  const kind = node.kind;\n  const key = node.key;\n\n  if (kind === \"get\" || kind === \"set\") {\n    this.word(kind);\n    this.space();\n  }\n\n  if (node.async) {\n    this._catchUp(\"start\", key.loc);\n\n    this.word(\"async\");\n    this.space();\n  }\n\n  if (kind === \"method\" || kind === \"init\") {\n    if (node.generator) {\n      this.tokenChar(42);\n    }\n  }\n\n  if (node.computed) {\n    this.tokenChar(91);\n    this.print(key, node);\n    this.tokenChar(93);\n  } else {\n    this.print(key, node);\n  }\n\n  if (node.optional) {\n    this.tokenChar(63);\n  }\n\n  this._params(node);\n}\n\nfunction _predicate(node) {\n  if (node.predicate) {\n    if (!node.returnType) {\n      this.tokenChar(58);\n    }\n\n    this.space();\n    this.print(node.predicate, node);\n  }\n}\n\nfunction _functionHead(node) {\n  if (node.async) {\n    this.word(\"async\");\n    this.space();\n  }\n\n  this.word(\"function\");\n  if (node.generator) this.tokenChar(42);\n  this.printInnerComments(node);\n  this.space();\n\n  if (node.id) {\n    this.print(node.id, node);\n  }\n\n  this._params(node);\n\n  if (node.type !== \"TSDeclareFunction\") {\n    this._predicate(node);\n  }\n}\n\nfunction FunctionExpression(node) {\n  this._functionHead(node);\n\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction ArrowFunctionExpression(node) {\n  if (node.async) {\n    this.word(\"async\");\n    this.space();\n  }\n\n  const firstParam = node.params[0];\n\n  if (!this.format.retainLines && !this.format.auxiliaryCommentBefore && !this.format.auxiliaryCommentAfter && node.params.length === 1 && isIdentifier(firstParam) && !hasTypesOrComments(node, firstParam)) {\n    this.print(firstParam, node);\n  } else {\n    this._params(node);\n  }\n\n  this._predicate(node);\n\n  this.space();\n  this.token(\"=>\");\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction hasTypesOrComments(node, param) {\n  var _param$leadingComment, _param$trailingCommen;\n\n  return !!(node.typeParameters || node.returnType || node.predicate || param.typeAnnotation || param.optional || (_param$leadingComment = param.leadingComments) != null && _param$leadingComment.length || (_param$trailingCommen = param.trailingComments) != null && _param$trailingCommen.length);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExportAllDeclaration = ExportAllDeclaration;\nexports.ExportDefaultDeclaration = ExportDefaultDeclaration;\nexports.ExportDefaultSpecifier = ExportDefaultSpecifier;\nexports.ExportNamedDeclaration = ExportNamedDeclaration;\nexports.ExportNamespaceSpecifier = ExportNamespaceSpecifier;\nexports.ExportSpecifier = ExportSpecifier;\nexports.ImportAttribute = ImportAttribute;\nexports.ImportDeclaration = ImportDeclaration;\nexports.ImportDefaultSpecifier = ImportDefaultSpecifier;\nexports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;\nexports.ImportSpecifier = ImportSpecifier;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  isClassDeclaration,\n  isExportDefaultSpecifier,\n  isExportNamespaceSpecifier,\n  isImportDefaultSpecifier,\n  isImportNamespaceSpecifier,\n  isStatement\n} = _t;\n\nfunction ImportSpecifier(node) {\n  if (node.importKind === \"type\" || node.importKind === \"typeof\") {\n    this.word(node.importKind);\n    this.space();\n  }\n\n  this.print(node.imported, node);\n\n  if (node.local && node.local.name !== node.imported.name) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(node.local, node);\n  }\n}\n\nfunction ImportDefaultSpecifier(node) {\n  this.print(node.local, node);\n}\n\nfunction ExportDefaultSpecifier(node) {\n  this.print(node.exported, node);\n}\n\nfunction ExportSpecifier(node) {\n  if (node.exportKind === \"type\") {\n    this.word(\"type\");\n    this.space();\n  }\n\n  this.print(node.local, node);\n\n  if (node.exported && node.local.name !== node.exported.name) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(node.exported, node);\n  }\n}\n\nfunction ExportNamespaceSpecifier(node) {\n  this.tokenChar(42);\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(node.exported, node);\n}\n\nfunction ExportAllDeclaration(node) {\n  this.word(\"export\");\n  this.space();\n\n  if (node.exportKind === \"type\") {\n    this.word(\"type\");\n    this.space();\n  }\n\n  this.tokenChar(42);\n  this.space();\n  this.word(\"from\");\n  this.space();\n  this.print(node.source, node);\n  this.printAssertions(node);\n  this.semicolon();\n}\n\nfunction ExportNamedDeclaration(node) {\n  {\n    if (this.format.decoratorsBeforeExport && isClassDeclaration(node.declaration)) {\n      this.printJoin(node.declaration.decorators, node);\n    }\n  }\n  this.word(\"export\");\n  this.space();\n\n  if (node.declaration) {\n    const declar = node.declaration;\n    this.print(declar, node);\n    if (!isStatement(declar)) this.semicolon();\n  } else {\n    if (node.exportKind === \"type\") {\n      this.word(\"type\");\n      this.space();\n    }\n\n    const specifiers = node.specifiers.slice(0);\n    let hasSpecial = false;\n\n    for (;;) {\n      const first = specifiers[0];\n\n      if (isExportDefaultSpecifier(first) || isExportNamespaceSpecifier(first)) {\n        hasSpecial = true;\n        this.print(specifiers.shift(), node);\n\n        if (specifiers.length) {\n          this.tokenChar(44);\n          this.space();\n        }\n      } else {\n        break;\n      }\n    }\n\n    if (specifiers.length || !specifiers.length && !hasSpecial) {\n      this.tokenChar(123);\n\n      if (specifiers.length) {\n        this.space();\n        this.printList(specifiers, node);\n        this.space();\n      }\n\n      this.tokenChar(125);\n    }\n\n    if (node.source) {\n      this.space();\n      this.word(\"from\");\n      this.space();\n      this.print(node.source, node);\n      this.printAssertions(node);\n    }\n\n    this.semicolon();\n  }\n}\n\nfunction ExportDefaultDeclaration(node) {\n  {\n    if (this.format.decoratorsBeforeExport && isClassDeclaration(node.declaration)) {\n      this.printJoin(node.declaration.decorators, node);\n    }\n  }\n  this.word(\"export\");\n  this.space();\n  this.word(\"default\");\n  this.space();\n  const declar = node.declaration;\n  this.print(declar, node);\n  if (!isStatement(declar)) this.semicolon();\n}\n\nfunction ImportDeclaration(node) {\n  this.word(\"import\");\n  this.space();\n  const isTypeKind = node.importKind === \"type\" || node.importKind === \"typeof\";\n\n  if (isTypeKind) {\n    this.word(node.importKind);\n    this.space();\n  }\n\n  const specifiers = node.specifiers.slice(0);\n  const hasSpecifiers = !!specifiers.length;\n\n  while (hasSpecifiers) {\n    const first = specifiers[0];\n\n    if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {\n      this.print(specifiers.shift(), node);\n\n      if (specifiers.length) {\n        this.tokenChar(44);\n        this.space();\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (specifiers.length) {\n    this.tokenChar(123);\n    this.space();\n    this.printList(specifiers, node);\n    this.space();\n    this.tokenChar(125);\n  } else if (isTypeKind && !hasSpecifiers) {\n    this.tokenChar(123);\n    this.tokenChar(125);\n  }\n\n  if (hasSpecifiers || isTypeKind) {\n    this.space();\n    this.word(\"from\");\n    this.space();\n  }\n\n  this.print(node.source, node);\n  this.printAssertions(node);\n  {\n    var _node$attributes;\n\n    if ((_node$attributes = node.attributes) != null && _node$attributes.length) {\n      this.space();\n      this.word(\"with\");\n      this.space();\n      this.printList(node.attributes, node);\n    }\n  }\n  this.semicolon();\n}\n\nfunction ImportAttribute(node) {\n  this.print(node.key);\n  this.tokenChar(58);\n  this.space();\n  this.print(node.value);\n}\n\nfunction ImportNamespaceSpecifier(node) {\n  this.tokenChar(42);\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(node.local, node);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArgumentPlaceholder = ArgumentPlaceholder;\nexports.ArrayPattern = exports.ArrayExpression = ArrayExpression;\nexports.BigIntLiteral = BigIntLiteral;\nexports.BooleanLiteral = BooleanLiteral;\nexports.DecimalLiteral = DecimalLiteral;\nexports.Identifier = Identifier;\nexports.NullLiteral = NullLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.ObjectPattern = exports.ObjectExpression = ObjectExpression;\nexports.ObjectMethod = ObjectMethod;\nexports.ObjectProperty = ObjectProperty;\nexports.PipelineBareFunction = PipelineBareFunction;\nexports.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;\nexports.PipelineTopicExpression = PipelineTopicExpression;\nexports.RecordExpression = RecordExpression;\nexports.RegExpLiteral = RegExpLiteral;\nexports.SpreadElement = exports.RestElement = RestElement;\nexports.StringLiteral = StringLiteral;\nexports.TopicReference = TopicReference;\nexports.TupleExpression = TupleExpression;\n\nvar _t = require(\"@babel/types\");\n\nvar _jsesc = require(\"jsesc\");\n\nconst {\n  isAssignmentPattern,\n  isIdentifier\n} = _t;\n\nfunction Identifier(node) {\n  this.exactSource(node.loc, () => {\n    this.word(node.name);\n  });\n}\n\nfunction ArgumentPlaceholder() {\n  this.tokenChar(63);\n}\n\nfunction RestElement(node) {\n  this.token(\"...\");\n  this.print(node.argument, node);\n}\n\nfunction ObjectExpression(node) {\n  const props = node.properties;\n  this.tokenChar(123);\n  this.printInnerComments(node);\n\n  if (props.length) {\n    this.space();\n    this.printList(props, node, {\n      indent: true,\n      statement: true\n    });\n    this.space();\n  }\n\n  this.tokenChar(125);\n}\n\nfunction ObjectMethod(node) {\n  this.printJoin(node.decorators, node);\n\n  this._methodHead(node);\n\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction ObjectProperty(node) {\n  this.printJoin(node.decorators, node);\n\n  if (node.computed) {\n    this.tokenChar(91);\n    this.print(node.key, node);\n    this.tokenChar(93);\n  } else {\n    if (isAssignmentPattern(node.value) && isIdentifier(node.key) && node.key.name === node.value.left.name) {\n      this.print(node.value, node);\n      return;\n    }\n\n    this.print(node.key, node);\n\n    if (node.shorthand && isIdentifier(node.key) && isIdentifier(node.value) && node.key.name === node.value.name) {\n      return;\n    }\n  }\n\n  this.tokenChar(58);\n  this.space();\n  this.print(node.value, node);\n}\n\nfunction ArrayExpression(node) {\n  const elems = node.elements;\n  const len = elems.length;\n  this.tokenChar(91);\n  this.printInnerComments(node);\n\n  for (let i = 0; i < elems.length; i++) {\n    const elem = elems[i];\n\n    if (elem) {\n      if (i > 0) this.space();\n      this.print(elem, node);\n      if (i < len - 1) this.tokenChar(44);\n    } else {\n      this.tokenChar(44);\n    }\n  }\n\n  this.tokenChar(93);\n}\n\nfunction RecordExpression(node) {\n  const props = node.properties;\n  let startToken;\n  let endToken;\n\n  if (this.format.recordAndTupleSyntaxType === \"bar\") {\n    startToken = \"{|\";\n    endToken = \"|}\";\n  } else if (this.format.recordAndTupleSyntaxType === \"hash\") {\n    startToken = \"#{\";\n    endToken = \"}\";\n  } else {\n    throw new Error(`The \"recordAndTupleSyntaxType\" generator option must be \"bar\" or \"hash\" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);\n  }\n\n  this.token(startToken);\n  this.printInnerComments(node);\n\n  if (props.length) {\n    this.space();\n    this.printList(props, node, {\n      indent: true,\n      statement: true\n    });\n    this.space();\n  }\n\n  this.token(endToken);\n}\n\nfunction TupleExpression(node) {\n  const elems = node.elements;\n  const len = elems.length;\n  let startToken;\n  let endToken;\n\n  if (this.format.recordAndTupleSyntaxType === \"bar\") {\n    startToken = \"[|\";\n    endToken = \"|]\";\n  } else if (this.format.recordAndTupleSyntaxType === \"hash\") {\n    startToken = \"#[\";\n    endToken = \"]\";\n  } else {\n    throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);\n  }\n\n  this.token(startToken);\n  this.printInnerComments(node);\n\n  for (let i = 0; i < elems.length; i++) {\n    const elem = elems[i];\n\n    if (elem) {\n      if (i > 0) this.space();\n      this.print(elem, node);\n      if (i < len - 1) this.tokenChar(44);\n    }\n  }\n\n  this.token(endToken);\n}\n\nfunction RegExpLiteral(node) {\n  this.word(`/${node.pattern}/${node.flags}`);\n}\n\nfunction BooleanLiteral(node) {\n  this.word(node.value ? \"true\" : \"false\");\n}\n\nfunction NullLiteral() {\n  this.word(\"null\");\n}\n\nfunction NumericLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n  const opts = this.format.jsescOption;\n  const value = node.value + \"\";\n\n  if (opts.numbers) {\n    this.number(_jsesc(node.value, opts));\n  } else if (raw == null) {\n    this.number(value);\n  } else if (this.format.minified) {\n    this.number(raw.length < value.length ? raw : value);\n  } else {\n    this.number(raw);\n  }\n}\n\nfunction StringLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n\n  if (!this.format.minified && raw !== undefined) {\n    this.token(raw);\n    return;\n  }\n\n  const val = _jsesc(node.value, Object.assign(this.format.jsescOption, this.format.jsonCompatibleStrings && {\n    json: true\n  }));\n\n  return this.token(val);\n}\n\nfunction BigIntLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n\n  if (!this.format.minified && raw !== undefined) {\n    this.word(raw);\n    return;\n  }\n\n  this.word(node.value + \"n\");\n}\n\nfunction DecimalLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n\n  if (!this.format.minified && raw !== undefined) {\n    this.word(raw);\n    return;\n  }\n\n  this.word(node.value + \"m\");\n}\n\nconst validTopicTokenSet = new Set([\"^^\", \"@@\", \"^\", \"%\", \"#\"]);\n\nfunction TopicReference() {\n  const {\n    topicToken\n  } = this.format;\n\n  if (validTopicTokenSet.has(topicToken)) {\n    this.token(topicToken);\n  } else {\n    const givenTopicTokenJSON = JSON.stringify(topicToken);\n    const validTopics = Array.from(validTopicTokenSet, v => JSON.stringify(v));\n    throw new Error(`The \"topicToken\" generator option must be one of ` + `${validTopics.join(\", \")} (${givenTopicTokenJSON} received instead).`);\n  }\n}\n\nfunction PipelineTopicExpression(node) {\n  this.print(node.expression, node);\n}\n\nfunction PipelineBareFunction(node) {\n  this.print(node.callee, node);\n}\n\nfunction PipelinePrimaryTopicReference() {\n  this.tokenChar(35);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AnyTypeAnnotation = AnyTypeAnnotation;\nexports.ArrayTypeAnnotation = ArrayTypeAnnotation;\nexports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;\nexports.BooleanTypeAnnotation = BooleanTypeAnnotation;\nexports.DeclareClass = DeclareClass;\nexports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;\nexports.DeclareExportDeclaration = DeclareExportDeclaration;\nexports.DeclareFunction = DeclareFunction;\nexports.DeclareInterface = DeclareInterface;\nexports.DeclareModule = DeclareModule;\nexports.DeclareModuleExports = DeclareModuleExports;\nexports.DeclareOpaqueType = DeclareOpaqueType;\nexports.DeclareTypeAlias = DeclareTypeAlias;\nexports.DeclareVariable = DeclareVariable;\nexports.DeclaredPredicate = DeclaredPredicate;\nexports.EmptyTypeAnnotation = EmptyTypeAnnotation;\nexports.EnumBooleanBody = EnumBooleanBody;\nexports.EnumBooleanMember = EnumBooleanMember;\nexports.EnumDeclaration = EnumDeclaration;\nexports.EnumDefaultedMember = EnumDefaultedMember;\nexports.EnumNumberBody = EnumNumberBody;\nexports.EnumNumberMember = EnumNumberMember;\nexports.EnumStringBody = EnumStringBody;\nexports.EnumStringMember = EnumStringMember;\nexports.EnumSymbolBody = EnumSymbolBody;\nexports.ExistsTypeAnnotation = ExistsTypeAnnotation;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.FunctionTypeParam = FunctionTypeParam;\nexports.IndexedAccessType = IndexedAccessType;\nexports.InferredPredicate = InferredPredicate;\nexports.InterfaceDeclaration = InterfaceDeclaration;\nexports.GenericTypeAnnotation = exports.ClassImplements = exports.InterfaceExtends = InterfaceExtends;\nexports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;\nexports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;\nexports.MixedTypeAnnotation = MixedTypeAnnotation;\nexports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nObject.defineProperty(exports, \"NumberLiteralTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _types2.NumericLiteral;\n  }\n});\nexports.NumberTypeAnnotation = NumberTypeAnnotation;\nexports.ObjectTypeAnnotation = ObjectTypeAnnotation;\nexports.ObjectTypeCallProperty = ObjectTypeCallProperty;\nexports.ObjectTypeIndexer = ObjectTypeIndexer;\nexports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;\nexports.ObjectTypeProperty = ObjectTypeProperty;\nexports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;\nexports.OpaqueType = OpaqueType;\nexports.OptionalIndexedAccessType = OptionalIndexedAccessType;\nexports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;\nObject.defineProperty(exports, \"StringLiteralTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _types2.StringLiteral;\n  }\n});\nexports.StringTypeAnnotation = StringTypeAnnotation;\nexports.SymbolTypeAnnotation = SymbolTypeAnnotation;\nexports.ThisTypeAnnotation = ThisTypeAnnotation;\nexports.TupleTypeAnnotation = TupleTypeAnnotation;\nexports.TypeAlias = TypeAlias;\nexports.TypeAnnotation = TypeAnnotation;\nexports.TypeCastExpression = TypeCastExpression;\nexports.TypeParameter = TypeParameter;\nexports.TypeParameterDeclaration = exports.TypeParameterInstantiation = TypeParameterInstantiation;\nexports.TypeofTypeAnnotation = TypeofTypeAnnotation;\nexports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.Variance = Variance;\nexports.VoidTypeAnnotation = VoidTypeAnnotation;\nexports._interfaceish = _interfaceish;\nexports._variance = _variance;\n\nvar _t = require(\"@babel/types\");\n\nvar _modules = require(\"./modules\");\n\nvar _types2 = require(\"./types\");\n\nconst {\n  isDeclareExportDeclaration,\n  isStatement\n} = _t;\n\nfunction AnyTypeAnnotation() {\n  this.word(\"any\");\n}\n\nfunction ArrayTypeAnnotation(node) {\n  this.print(node.elementType, node, true);\n  this.tokenChar(91);\n  this.tokenChar(93);\n}\n\nfunction BooleanTypeAnnotation() {\n  this.word(\"boolean\");\n}\n\nfunction BooleanLiteralTypeAnnotation(node) {\n  this.word(node.value ? \"true\" : \"false\");\n}\n\nfunction NullLiteralTypeAnnotation() {\n  this.word(\"null\");\n}\n\nfunction DeclareClass(node, parent) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.word(\"class\");\n  this.space();\n\n  this._interfaceish(node);\n}\n\nfunction DeclareFunction(node, parent) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.word(\"function\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.id.typeAnnotation.typeAnnotation, node);\n\n  if (node.predicate) {\n    this.space();\n    this.print(node.predicate, node);\n  }\n\n  this.semicolon();\n}\n\nfunction InferredPredicate() {\n  this.tokenChar(37);\n  this.word(\"checks\");\n}\n\nfunction DeclaredPredicate(node) {\n  this.tokenChar(37);\n  this.word(\"checks\");\n  this.tokenChar(40);\n  this.print(node.value, node);\n  this.tokenChar(41);\n}\n\nfunction DeclareInterface(node) {\n  this.word(\"declare\");\n  this.space();\n  this.InterfaceDeclaration(node);\n}\n\nfunction DeclareModule(node) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.space();\n  this.print(node.id, node);\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction DeclareModuleExports(node) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.tokenChar(46);\n  this.word(\"exports\");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction DeclareTypeAlias(node) {\n  this.word(\"declare\");\n  this.space();\n  this.TypeAlias(node);\n}\n\nfunction DeclareOpaqueType(node, parent) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.OpaqueType(node);\n}\n\nfunction DeclareVariable(node, parent) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.word(\"var\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.id.typeAnnotation, node);\n  this.semicolon();\n}\n\nfunction DeclareExportDeclaration(node) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"export\");\n  this.space();\n\n  if (node.default) {\n    this.word(\"default\");\n    this.space();\n  }\n\n  FlowExportDeclaration.call(this, node);\n}\n\nfunction DeclareExportAllDeclaration(node) {\n  this.word(\"declare\");\n  this.space();\n\n  _modules.ExportAllDeclaration.call(this, node);\n}\n\nfunction EnumDeclaration(node) {\n  const {\n    id,\n    body\n  } = node;\n  this.word(\"enum\");\n  this.space();\n  this.print(id, node);\n  this.print(body, node);\n}\n\nfunction enumExplicitType(context, name, hasExplicitType) {\n  if (hasExplicitType) {\n    context.space();\n    context.word(\"of\");\n    context.space();\n    context.word(name);\n  }\n\n  context.space();\n}\n\nfunction enumBody(context, node) {\n  const {\n    members\n  } = node;\n  context.token(\"{\");\n  context.indent();\n  context.newline();\n\n  for (const member of members) {\n    context.print(member, node);\n    context.newline();\n  }\n\n  if (node.hasUnknownMembers) {\n    context.token(\"...\");\n    context.newline();\n  }\n\n  context.dedent();\n  context.token(\"}\");\n}\n\nfunction EnumBooleanBody(node) {\n  const {\n    explicitType\n  } = node;\n  enumExplicitType(this, \"boolean\", explicitType);\n  enumBody(this, node);\n}\n\nfunction EnumNumberBody(node) {\n  const {\n    explicitType\n  } = node;\n  enumExplicitType(this, \"number\", explicitType);\n  enumBody(this, node);\n}\n\nfunction EnumStringBody(node) {\n  const {\n    explicitType\n  } = node;\n  enumExplicitType(this, \"string\", explicitType);\n  enumBody(this, node);\n}\n\nfunction EnumSymbolBody(node) {\n  enumExplicitType(this, \"symbol\", true);\n  enumBody(this, node);\n}\n\nfunction EnumDefaultedMember(node) {\n  const {\n    id\n  } = node;\n  this.print(id, node);\n  this.tokenChar(44);\n}\n\nfunction enumInitializedMember(context, node) {\n  const {\n    id,\n    init\n  } = node;\n  context.print(id, node);\n  context.space();\n  context.token(\"=\");\n  context.space();\n  context.print(init, node);\n  context.token(\",\");\n}\n\nfunction EnumBooleanMember(node) {\n  enumInitializedMember(this, node);\n}\n\nfunction EnumNumberMember(node) {\n  enumInitializedMember(this, node);\n}\n\nfunction EnumStringMember(node) {\n  enumInitializedMember(this, node);\n}\n\nfunction FlowExportDeclaration(node) {\n  if (node.declaration) {\n    const declar = node.declaration;\n    this.print(declar, node);\n    if (!isStatement(declar)) this.semicolon();\n  } else {\n    this.tokenChar(123);\n\n    if (node.specifiers.length) {\n      this.space();\n      this.printList(node.specifiers, node);\n      this.space();\n    }\n\n    this.tokenChar(125);\n\n    if (node.source) {\n      this.space();\n      this.word(\"from\");\n      this.space();\n      this.print(node.source, node);\n    }\n\n    this.semicolon();\n  }\n}\n\nfunction ExistsTypeAnnotation() {\n  this.tokenChar(42);\n}\n\nfunction FunctionTypeAnnotation(node, parent) {\n  this.print(node.typeParameters, node);\n  this.tokenChar(40);\n\n  if (node.this) {\n    this.word(\"this\");\n    this.tokenChar(58);\n    this.space();\n    this.print(node.this.typeAnnotation, node);\n\n    if (node.params.length || node.rest) {\n      this.tokenChar(44);\n      this.space();\n    }\n  }\n\n  this.printList(node.params, node);\n\n  if (node.rest) {\n    if (node.params.length) {\n      this.tokenChar(44);\n      this.space();\n    }\n\n    this.token(\"...\");\n    this.print(node.rest, node);\n  }\n\n  this.tokenChar(41);\n\n  if (parent && (parent.type === \"ObjectTypeCallProperty\" || parent.type === \"DeclareFunction\" || parent.type === \"ObjectTypeProperty\" && parent.method)) {\n    this.tokenChar(58);\n  } else {\n    this.space();\n    this.token(\"=>\");\n  }\n\n  this.space();\n  this.print(node.returnType, node);\n}\n\nfunction FunctionTypeParam(node) {\n  this.print(node.name, node);\n  if (node.optional) this.tokenChar(63);\n\n  if (node.name) {\n    this.tokenChar(58);\n    this.space();\n  }\n\n  this.print(node.typeAnnotation, node);\n}\n\nfunction InterfaceExtends(node) {\n  this.print(node.id, node);\n  this.print(node.typeParameters, node, true);\n}\n\nfunction _interfaceish(node) {\n  var _node$extends;\n\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n\n  if ((_node$extends = node.extends) != null && _node$extends.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(node.extends, node);\n  }\n\n  if (node.mixins && node.mixins.length) {\n    this.space();\n    this.word(\"mixins\");\n    this.space();\n    this.printList(node.mixins, node);\n  }\n\n  if (node.implements && node.implements.length) {\n    this.space();\n    this.word(\"implements\");\n    this.space();\n    this.printList(node.implements, node);\n  }\n\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction _variance(node) {\n  if (node.variance) {\n    if (node.variance.kind === \"plus\") {\n      this.tokenChar(43);\n    } else if (node.variance.kind === \"minus\") {\n      this.tokenChar(45);\n    }\n  }\n}\n\nfunction InterfaceDeclaration(node) {\n  this.word(\"interface\");\n  this.space();\n\n  this._interfaceish(node);\n}\n\nfunction andSeparator() {\n  this.space();\n  this.tokenChar(38);\n  this.space();\n}\n\nfunction InterfaceTypeAnnotation(node) {\n  this.word(\"interface\");\n\n  if (node.extends && node.extends.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(node.extends, node);\n  }\n\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction IntersectionTypeAnnotation(node) {\n  this.printJoin(node.types, node, {\n    separator: andSeparator\n  });\n}\n\nfunction MixedTypeAnnotation() {\n  this.word(\"mixed\");\n}\n\nfunction EmptyTypeAnnotation() {\n  this.word(\"empty\");\n}\n\nfunction NullableTypeAnnotation(node) {\n  this.tokenChar(63);\n  this.print(node.typeAnnotation, node);\n}\n\nfunction NumberTypeAnnotation() {\n  this.word(\"number\");\n}\n\nfunction StringTypeAnnotation() {\n  this.word(\"string\");\n}\n\nfunction ThisTypeAnnotation() {\n  this.word(\"this\");\n}\n\nfunction TupleTypeAnnotation(node) {\n  this.tokenChar(91);\n  this.printList(node.types, node);\n  this.tokenChar(93);\n}\n\nfunction TypeofTypeAnnotation(node) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.argument, node);\n}\n\nfunction TypeAlias(node) {\n  this.word(\"type\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(node.right, node);\n  this.semicolon();\n}\n\nfunction TypeAnnotation(node) {\n  this.tokenChar(58);\n  this.space();\n  if (node.optional) this.tokenChar(63);\n  this.print(node.typeAnnotation, node);\n}\n\nfunction TypeParameterInstantiation(node) {\n  this.tokenChar(60);\n  this.printList(node.params, node, {});\n  this.tokenChar(62);\n}\n\nfunction TypeParameter(node) {\n  this._variance(node);\n\n  this.word(node.name);\n\n  if (node.bound) {\n    this.print(node.bound, node);\n  }\n\n  if (node.default) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.default, node);\n  }\n}\n\nfunction OpaqueType(node) {\n  this.word(\"opaque\");\n  this.space();\n  this.word(\"type\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n\n  if (node.supertype) {\n    this.tokenChar(58);\n    this.space();\n    this.print(node.supertype, node);\n  }\n\n  if (node.impltype) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.impltype, node);\n  }\n\n  this.semicolon();\n}\n\nfunction ObjectTypeAnnotation(node) {\n  if (node.exact) {\n    this.token(\"{|\");\n  } else {\n    this.tokenChar(123);\n  }\n\n  const props = [...node.properties, ...(node.callProperties || []), ...(node.indexers || []), ...(node.internalSlots || [])];\n\n  if (props.length) {\n    this.space();\n    this.printJoin(props, node, {\n      addNewlines(leading) {\n        if (leading && !props[0]) return 1;\n      },\n\n      indent: true,\n      statement: true,\n      iterator: () => {\n        if (props.length !== 1 || node.inexact) {\n          this.tokenChar(44);\n          this.space();\n        }\n      }\n    });\n    this.space();\n  }\n\n  if (node.inexact) {\n    this.indent();\n    this.token(\"...\");\n\n    if (props.length) {\n      this.newline();\n    }\n\n    this.dedent();\n  }\n\n  if (node.exact) {\n    this.token(\"|}\");\n  } else {\n    this.tokenChar(125);\n  }\n}\n\nfunction ObjectTypeInternalSlot(node) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n\n  this.tokenChar(91);\n  this.tokenChar(91);\n  this.print(node.id, node);\n  this.tokenChar(93);\n  this.tokenChar(93);\n  if (node.optional) this.tokenChar(63);\n\n  if (!node.method) {\n    this.tokenChar(58);\n    this.space();\n  }\n\n  this.print(node.value, node);\n}\n\nfunction ObjectTypeCallProperty(node) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n\n  this.print(node.value, node);\n}\n\nfunction ObjectTypeIndexer(node) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n\n  this._variance(node);\n\n  this.tokenChar(91);\n\n  if (node.id) {\n    this.print(node.id, node);\n    this.tokenChar(58);\n    this.space();\n  }\n\n  this.print(node.key, node);\n  this.tokenChar(93);\n  this.tokenChar(58);\n  this.space();\n  this.print(node.value, node);\n}\n\nfunction ObjectTypeProperty(node) {\n  if (node.proto) {\n    this.word(\"proto\");\n    this.space();\n  }\n\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n\n  if (node.kind === \"get\" || node.kind === \"set\") {\n    this.word(node.kind);\n    this.space();\n  }\n\n  this._variance(node);\n\n  this.print(node.key, node);\n  if (node.optional) this.tokenChar(63);\n\n  if (!node.method) {\n    this.tokenChar(58);\n    this.space();\n  }\n\n  this.print(node.value, node);\n}\n\nfunction ObjectTypeSpreadProperty(node) {\n  this.token(\"...\");\n  this.print(node.argument, node);\n}\n\nfunction QualifiedTypeIdentifier(node) {\n  this.print(node.qualification, node);\n  this.tokenChar(46);\n  this.print(node.id, node);\n}\n\nfunction SymbolTypeAnnotation() {\n  this.word(\"symbol\");\n}\n\nfunction orSeparator() {\n  this.space();\n  this.tokenChar(124);\n  this.space();\n}\n\nfunction UnionTypeAnnotation(node) {\n  this.printJoin(node.types, node, {\n    separator: orSeparator\n  });\n}\n\nfunction TypeCastExpression(node) {\n  this.tokenChar(40);\n  this.print(node.expression, node);\n  this.print(node.typeAnnotation, node);\n  this.tokenChar(41);\n}\n\nfunction Variance(node) {\n  if (node.kind === \"plus\") {\n    this.tokenChar(43);\n  } else {\n    this.tokenChar(45);\n  }\n}\n\nfunction VoidTypeAnnotation() {\n  this.word(\"void\");\n}\n\nfunction IndexedAccessType(node) {\n  this.print(node.objectType, node, true);\n  this.tokenChar(91);\n  this.print(node.indexType, node);\n  this.tokenChar(93);\n}\n\nfunction OptionalIndexedAccessType(node) {\n  this.print(node.objectType, node);\n\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n\n  this.tokenChar(91);\n  this.print(node.indexType, node);\n  this.tokenChar(93);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BlockStatement = BlockStatement;\nexports.Directive = Directive;\nexports.DirectiveLiteral = DirectiveLiteral;\nexports.File = File;\nexports.InterpreterDirective = InterpreterDirective;\nexports.Placeholder = Placeholder;\nexports.Program = Program;\n\nfunction File(node) {\n  if (node.program) {\n    this.print(node.program.interpreter, node);\n  }\n\n  this.print(node.program, node);\n}\n\nfunction Program(node) {\n  this.printInnerComments(node, false);\n  this.printSequence(node.directives, node);\n  if (node.directives && node.directives.length) this.newline();\n  this.printSequence(node.body, node);\n}\n\nfunction BlockStatement(node) {\n  var _node$directives;\n\n  this.tokenChar(123);\n  this.printInnerComments(node);\n  const hasDirectives = (_node$directives = node.directives) == null ? void 0 : _node$directives.length;\n\n  if (node.body.length || hasDirectives) {\n    this.newline();\n    this.printSequence(node.directives, node, {\n      indent: true\n    });\n    if (hasDirectives) this.newline();\n    this.printSequence(node.body, node, {\n      indent: true\n    });\n    this.removeTrailingNewline();\n    this.source(\"end\", node.loc);\n    if (!this.endsWith(10)) this.newline();\n    this.rightBrace();\n  } else {\n    this.source(\"end\", node.loc);\n    this.tokenChar(125);\n  }\n}\n\nfunction Directive(node) {\n  this.print(node.value, node);\n  this.semicolon();\n}\n\nconst unescapedSingleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*'/;\nconst unescapedDoubleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*\"/;\n\nfunction DirectiveLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n\n  if (!this.format.minified && raw !== undefined) {\n    this.token(raw);\n    return;\n  }\n\n  const {\n    value\n  } = node;\n\n  if (!unescapedDoubleQuoteRE.test(value)) {\n    this.token(`\"${value}\"`);\n  } else if (!unescapedSingleQuoteRE.test(value)) {\n    this.token(`'${value}'`);\n  } else {\n    throw new Error(\"Malformed AST: it is not possible to print a directive containing\" + \" both unescaped single and double quotes.\");\n  }\n}\n\nfunction InterpreterDirective(node) {\n  this.token(`#!${node.value}\\n`, true);\n}\n\nfunction Placeholder(node) {\n  this.token(\"%%\");\n  this.print(node.name);\n  this.token(\"%%\");\n\n  if (node.expectedNode === \"Statement\") {\n    this.semicolon();\n  }\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JSXAttribute = JSXAttribute;\nexports.JSXClosingElement = JSXClosingElement;\nexports.JSXClosingFragment = JSXClosingFragment;\nexports.JSXElement = JSXElement;\nexports.JSXEmptyExpression = JSXEmptyExpression;\nexports.JSXExpressionContainer = JSXExpressionContainer;\nexports.JSXFragment = JSXFragment;\nexports.JSXIdentifier = JSXIdentifier;\nexports.JSXMemberExpression = JSXMemberExpression;\nexports.JSXNamespacedName = JSXNamespacedName;\nexports.JSXOpeningElement = JSXOpeningElement;\nexports.JSXOpeningFragment = JSXOpeningFragment;\nexports.JSXSpreadAttribute = JSXSpreadAttribute;\nexports.JSXSpreadChild = JSXSpreadChild;\nexports.JSXText = JSXText;\n\nfunction JSXAttribute(node) {\n  this.print(node.name, node);\n\n  if (node.value) {\n    this.tokenChar(61);\n    this.print(node.value, node);\n  }\n}\n\nfunction JSXIdentifier(node) {\n  this.word(node.name);\n}\n\nfunction JSXNamespacedName(node) {\n  this.print(node.namespace, node);\n  this.tokenChar(58);\n  this.print(node.name, node);\n}\n\nfunction JSXMemberExpression(node) {\n  this.print(node.object, node);\n  this.tokenChar(46);\n  this.print(node.property, node);\n}\n\nfunction JSXSpreadAttribute(node) {\n  this.tokenChar(123);\n  this.token(\"...\");\n  this.print(node.argument, node);\n  this.tokenChar(125);\n}\n\nfunction JSXExpressionContainer(node) {\n  this.tokenChar(123);\n  this.print(node.expression, node);\n  this.tokenChar(125);\n}\n\nfunction JSXSpreadChild(node) {\n  this.tokenChar(123);\n  this.token(\"...\");\n  this.print(node.expression, node);\n  this.tokenChar(125);\n}\n\nfunction JSXText(node) {\n  const raw = this.getPossibleRaw(node);\n\n  if (raw !== undefined) {\n    this.token(raw);\n  } else {\n    this.token(node.value);\n  }\n}\n\nfunction JSXElement(node) {\n  const open = node.openingElement;\n  this.print(open, node);\n  if (open.selfClosing) return;\n  this.indent();\n\n  for (const child of node.children) {\n    this.print(child, node);\n  }\n\n  this.dedent();\n  this.print(node.closingElement, node);\n}\n\nfunction spaceSeparator() {\n  this.space();\n}\n\nfunction JSXOpeningElement(node) {\n  this.tokenChar(60);\n  this.print(node.name, node);\n  this.print(node.typeParameters, node);\n\n  if (node.attributes.length > 0) {\n    this.space();\n    this.printJoin(node.attributes, node, {\n      separator: spaceSeparator\n    });\n  }\n\n  if (node.selfClosing) {\n    this.space();\n    this.token(\"/>\");\n  } else {\n    this.tokenChar(62);\n  }\n}\n\nfunction JSXClosingElement(node) {\n  this.token(\"</\");\n  this.print(node.name, node);\n  this.tokenChar(62);\n}\n\nfunction JSXEmptyExpression(node) {\n  this.printInnerComments(node);\n}\n\nfunction JSXFragment(node) {\n  this.print(node.openingFragment, node);\n  this.indent();\n\n  for (const child of node.children) {\n    this.print(child, node);\n  }\n\n  this.dedent();\n  this.print(node.closingFragment, node);\n}\n\nfunction JSXOpeningFragment() {\n  this.tokenChar(60);\n  this.tokenChar(62);\n}\n\nfunction JSXClosingFragment() {\n  this.token(\"</\");\n  this.tokenChar(62);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TSAnyKeyword = TSAnyKeyword;\nexports.TSArrayType = TSArrayType;\nexports.TSAsExpression = TSAsExpression;\nexports.TSBigIntKeyword = TSBigIntKeyword;\nexports.TSBooleanKeyword = TSBooleanKeyword;\nexports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;\nexports.TSConditionalType = TSConditionalType;\nexports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;\nexports.TSConstructorType = TSConstructorType;\nexports.TSDeclareFunction = TSDeclareFunction;\nexports.TSDeclareMethod = TSDeclareMethod;\nexports.TSEnumDeclaration = TSEnumDeclaration;\nexports.TSEnumMember = TSEnumMember;\nexports.TSExportAssignment = TSExportAssignment;\nexports.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;\nexports.TSExternalModuleReference = TSExternalModuleReference;\nexports.TSFunctionType = TSFunctionType;\nexports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;\nexports.TSImportType = TSImportType;\nexports.TSIndexSignature = TSIndexSignature;\nexports.TSIndexedAccessType = TSIndexedAccessType;\nexports.TSInferType = TSInferType;\nexports.TSInstantiationExpression = TSInstantiationExpression;\nexports.TSInterfaceBody = TSInterfaceBody;\nexports.TSInterfaceDeclaration = TSInterfaceDeclaration;\nexports.TSIntersectionType = TSIntersectionType;\nexports.TSIntrinsicKeyword = TSIntrinsicKeyword;\nexports.TSLiteralType = TSLiteralType;\nexports.TSMappedType = TSMappedType;\nexports.TSMethodSignature = TSMethodSignature;\nexports.TSModuleBlock = TSModuleBlock;\nexports.TSModuleDeclaration = TSModuleDeclaration;\nexports.TSNamedTupleMember = TSNamedTupleMember;\nexports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;\nexports.TSNeverKeyword = TSNeverKeyword;\nexports.TSNonNullExpression = TSNonNullExpression;\nexports.TSNullKeyword = TSNullKeyword;\nexports.TSNumberKeyword = TSNumberKeyword;\nexports.TSObjectKeyword = TSObjectKeyword;\nexports.TSOptionalType = TSOptionalType;\nexports.TSParameterProperty = TSParameterProperty;\nexports.TSParenthesizedType = TSParenthesizedType;\nexports.TSPropertySignature = TSPropertySignature;\nexports.TSQualifiedName = TSQualifiedName;\nexports.TSRestType = TSRestType;\nexports.TSStringKeyword = TSStringKeyword;\nexports.TSSymbolKeyword = TSSymbolKeyword;\nexports.TSThisType = TSThisType;\nexports.TSTupleType = TSTupleType;\nexports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;\nexports.TSTypeAnnotation = TSTypeAnnotation;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSTypeLiteral = TSTypeLiteral;\nexports.TSTypeOperator = TSTypeOperator;\nexports.TSTypeParameter = TSTypeParameter;\nexports.TSTypeParameterDeclaration = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;\nexports.TSTypePredicate = TSTypePredicate;\nexports.TSTypeQuery = TSTypeQuery;\nexports.TSTypeReference = TSTypeReference;\nexports.TSUndefinedKeyword = TSUndefinedKeyword;\nexports.TSUnionType = TSUnionType;\nexports.TSUnknownKeyword = TSUnknownKeyword;\nexports.TSVoidKeyword = TSVoidKeyword;\nexports.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;\nexports.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;\nexports.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;\nexports.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;\nexports.tsPrintTypeLiteralOrInterfaceBody = tsPrintTypeLiteralOrInterfaceBody;\n\nfunction TSTypeAnnotation(node) {\n  this.tokenChar(58);\n  this.space();\n  if (node.optional) this.tokenChar(63);\n  this.print(node.typeAnnotation, node);\n}\n\nfunction TSTypeParameterInstantiation(node, parent) {\n  this.tokenChar(60);\n  this.printList(node.params, node, {});\n\n  if (parent.type === \"ArrowFunctionExpression\" && node.params.length === 1) {\n    this.tokenChar(44);\n  }\n\n  this.tokenChar(62);\n}\n\nfunction TSTypeParameter(node) {\n  if (node.in) {\n    this.word(\"in\");\n    this.space();\n  }\n\n  if (node.out) {\n    this.word(\"out\");\n    this.space();\n  }\n\n  this.word(node.name);\n\n  if (node.constraint) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.print(node.constraint, node);\n  }\n\n  if (node.default) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.default, node);\n  }\n}\n\nfunction TSParameterProperty(node) {\n  if (node.accessibility) {\n    this.word(node.accessibility);\n    this.space();\n  }\n\n  if (node.readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this._param(node.parameter);\n}\n\nfunction TSDeclareFunction(node) {\n  if (node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this._functionHead(node);\n\n  this.tokenChar(59);\n}\n\nfunction TSDeclareMethod(node) {\n  this._classMethodHead(node);\n\n  this.tokenChar(59);\n}\n\nfunction TSQualifiedName(node) {\n  this.print(node.left, node);\n  this.tokenChar(46);\n  this.print(node.right, node);\n}\n\nfunction TSCallSignatureDeclaration(node) {\n  this.tsPrintSignatureDeclarationBase(node);\n  this.tokenChar(59);\n}\n\nfunction TSConstructSignatureDeclaration(node) {\n  this.word(\"new\");\n  this.space();\n  this.tsPrintSignatureDeclarationBase(node);\n  this.tokenChar(59);\n}\n\nfunction TSPropertySignature(node) {\n  const {\n    readonly,\n    initializer\n  } = node;\n\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this.tsPrintPropertyOrMethodName(node);\n  this.print(node.typeAnnotation, node);\n\n  if (initializer) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(initializer, node);\n  }\n\n  this.tokenChar(59);\n}\n\nfunction tsPrintPropertyOrMethodName(node) {\n  if (node.computed) {\n    this.tokenChar(91);\n  }\n\n  this.print(node.key, node);\n\n  if (node.computed) {\n    this.tokenChar(93);\n  }\n\n  if (node.optional) {\n    this.tokenChar(63);\n  }\n}\n\nfunction TSMethodSignature(node) {\n  const {\n    kind\n  } = node;\n\n  if (kind === \"set\" || kind === \"get\") {\n    this.word(kind);\n    this.space();\n  }\n\n  this.tsPrintPropertyOrMethodName(node);\n  this.tsPrintSignatureDeclarationBase(node);\n  this.tokenChar(59);\n}\n\nfunction TSIndexSignature(node) {\n  const {\n    readonly,\n    static: isStatic\n  } = node;\n\n  if (isStatic) {\n    this.word(\"static\");\n    this.space();\n  }\n\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this.tokenChar(91);\n\n  this._parameters(node.parameters, node);\n\n  this.tokenChar(93);\n  this.print(node.typeAnnotation, node);\n  this.tokenChar(59);\n}\n\nfunction TSAnyKeyword() {\n  this.word(\"any\");\n}\n\nfunction TSBigIntKeyword() {\n  this.word(\"bigint\");\n}\n\nfunction TSUnknownKeyword() {\n  this.word(\"unknown\");\n}\n\nfunction TSNumberKeyword() {\n  this.word(\"number\");\n}\n\nfunction TSObjectKeyword() {\n  this.word(\"object\");\n}\n\nfunction TSBooleanKeyword() {\n  this.word(\"boolean\");\n}\n\nfunction TSStringKeyword() {\n  this.word(\"string\");\n}\n\nfunction TSSymbolKeyword() {\n  this.word(\"symbol\");\n}\n\nfunction TSVoidKeyword() {\n  this.word(\"void\");\n}\n\nfunction TSUndefinedKeyword() {\n  this.word(\"undefined\");\n}\n\nfunction TSNullKeyword() {\n  this.word(\"null\");\n}\n\nfunction TSNeverKeyword() {\n  this.word(\"never\");\n}\n\nfunction TSIntrinsicKeyword() {\n  this.word(\"intrinsic\");\n}\n\nfunction TSThisType() {\n  this.word(\"this\");\n}\n\nfunction TSFunctionType(node) {\n  this.tsPrintFunctionOrConstructorType(node);\n}\n\nfunction TSConstructorType(node) {\n  if (node.abstract) {\n    this.word(\"abstract\");\n    this.space();\n  }\n\n  this.word(\"new\");\n  this.space();\n  this.tsPrintFunctionOrConstructorType(node);\n}\n\nfunction tsPrintFunctionOrConstructorType(node) {\n  const {\n    typeParameters\n  } = node;\n  const parameters = node.parameters;\n  this.print(typeParameters, node);\n  this.tokenChar(40);\n\n  this._parameters(parameters, node);\n\n  this.tokenChar(41);\n  this.space();\n  this.token(\"=>\");\n  this.space();\n  const returnType = node.typeAnnotation;\n  this.print(returnType.typeAnnotation, node);\n}\n\nfunction TSTypeReference(node) {\n  this.print(node.typeName, node, true);\n  this.print(node.typeParameters, node, true);\n}\n\nfunction TSTypePredicate(node) {\n  if (node.asserts) {\n    this.word(\"asserts\");\n    this.space();\n  }\n\n  this.print(node.parameterName);\n\n  if (node.typeAnnotation) {\n    this.space();\n    this.word(\"is\");\n    this.space();\n    this.print(node.typeAnnotation.typeAnnotation);\n  }\n}\n\nfunction TSTypeQuery(node) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.exprName);\n\n  if (node.typeParameters) {\n    this.print(node.typeParameters, node);\n  }\n}\n\nfunction TSTypeLiteral(node) {\n  this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);\n}\n\nfunction tsPrintTypeLiteralOrInterfaceBody(members, node) {\n  tsPrintBraced(this, members, node);\n}\n\nfunction tsPrintBraced(printer, members, node) {\n  printer.token(\"{\");\n\n  if (members.length) {\n    printer.indent();\n    printer.newline();\n\n    for (const member of members) {\n      printer.print(member, node);\n      printer.newline();\n    }\n\n    printer.dedent();\n    printer.rightBrace();\n  } else {\n    printer.token(\"}\");\n  }\n}\n\nfunction TSArrayType(node) {\n  this.print(node.elementType, node, true);\n  this.token(\"[]\");\n}\n\nfunction TSTupleType(node) {\n  this.tokenChar(91);\n  this.printList(node.elementTypes, node);\n  this.tokenChar(93);\n}\n\nfunction TSOptionalType(node) {\n  this.print(node.typeAnnotation, node);\n  this.tokenChar(63);\n}\n\nfunction TSRestType(node) {\n  this.token(\"...\");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction TSNamedTupleMember(node) {\n  this.print(node.label, node);\n  if (node.optional) this.tokenChar(63);\n  this.tokenChar(58);\n  this.space();\n  this.print(node.elementType, node);\n}\n\nfunction TSUnionType(node) {\n  tsPrintUnionOrIntersectionType(this, node, \"|\");\n}\n\nfunction TSIntersectionType(node) {\n  tsPrintUnionOrIntersectionType(this, node, \"&\");\n}\n\nfunction tsPrintUnionOrIntersectionType(printer, node, sep) {\n  printer.printJoin(node.types, node, {\n    separator() {\n      this.space();\n      this.token(sep);\n      this.space();\n    }\n\n  });\n}\n\nfunction TSConditionalType(node) {\n  this.print(node.checkType);\n  this.space();\n  this.word(\"extends\");\n  this.space();\n  this.print(node.extendsType);\n  this.space();\n  this.tokenChar(63);\n  this.space();\n  this.print(node.trueType);\n  this.space();\n  this.tokenChar(58);\n  this.space();\n  this.print(node.falseType);\n}\n\nfunction TSInferType(node) {\n  this.token(\"infer\");\n  this.space();\n  this.print(node.typeParameter);\n}\n\nfunction TSParenthesizedType(node) {\n  this.tokenChar(40);\n  this.print(node.typeAnnotation, node);\n  this.tokenChar(41);\n}\n\nfunction TSTypeOperator(node) {\n  this.word(node.operator);\n  this.space();\n  this.print(node.typeAnnotation, node);\n}\n\nfunction TSIndexedAccessType(node) {\n  this.print(node.objectType, node, true);\n  this.tokenChar(91);\n  this.print(node.indexType, node);\n  this.tokenChar(93);\n}\n\nfunction TSMappedType(node) {\n  const {\n    nameType,\n    optional,\n    readonly,\n    typeParameter\n  } = node;\n  this.tokenChar(123);\n  this.space();\n\n  if (readonly) {\n    tokenIfPlusMinus(this, readonly);\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this.tokenChar(91);\n  this.word(typeParameter.name);\n  this.space();\n  this.word(\"in\");\n  this.space();\n  this.print(typeParameter.constraint, typeParameter);\n\n  if (nameType) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(nameType, node);\n  }\n\n  this.tokenChar(93);\n\n  if (optional) {\n    tokenIfPlusMinus(this, optional);\n    this.tokenChar(63);\n  }\n\n  this.tokenChar(58);\n  this.space();\n  this.print(node.typeAnnotation, node);\n  this.space();\n  this.tokenChar(125);\n}\n\nfunction tokenIfPlusMinus(self, tok) {\n  if (tok !== true) {\n    self.token(tok);\n  }\n}\n\nfunction TSLiteralType(node) {\n  this.print(node.literal, node);\n}\n\nfunction TSExpressionWithTypeArguments(node) {\n  this.print(node.expression, node);\n  this.print(node.typeParameters, node);\n}\n\nfunction TSInterfaceDeclaration(node) {\n  const {\n    declare,\n    id,\n    typeParameters,\n    extends: extendz,\n    body\n  } = node;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.word(\"interface\");\n  this.space();\n  this.print(id, node);\n  this.print(typeParameters, node);\n\n  if (extendz != null && extendz.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(extendz, node);\n  }\n\n  this.space();\n  this.print(body, node);\n}\n\nfunction TSInterfaceBody(node) {\n  this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);\n}\n\nfunction TSTypeAliasDeclaration(node) {\n  const {\n    declare,\n    id,\n    typeParameters,\n    typeAnnotation\n  } = node;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.word(\"type\");\n  this.space();\n  this.print(id, node);\n  this.print(typeParameters, node);\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(typeAnnotation, node);\n  this.tokenChar(59);\n}\n\nfunction TSAsExpression(node) {\n  const {\n    expression,\n    typeAnnotation\n  } = node;\n  this.print(expression, node);\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(typeAnnotation, node);\n}\n\nfunction TSTypeAssertion(node) {\n  const {\n    typeAnnotation,\n    expression\n  } = node;\n  this.tokenChar(60);\n  this.print(typeAnnotation, node);\n  this.tokenChar(62);\n  this.space();\n  this.print(expression, node);\n}\n\nfunction TSInstantiationExpression(node) {\n  this.print(node.expression, node);\n  this.print(node.typeParameters, node);\n}\n\nfunction TSEnumDeclaration(node) {\n  const {\n    declare,\n    const: isConst,\n    id,\n    members\n  } = node;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (isConst) {\n    this.word(\"const\");\n    this.space();\n  }\n\n  this.word(\"enum\");\n  this.space();\n  this.print(id, node);\n  this.space();\n  tsPrintBraced(this, members, node);\n}\n\nfunction TSEnumMember(node) {\n  const {\n    id,\n    initializer\n  } = node;\n  this.print(id, node);\n\n  if (initializer) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(initializer, node);\n  }\n\n  this.tokenChar(44);\n}\n\nfunction TSModuleDeclaration(node) {\n  const {\n    declare,\n    id\n  } = node;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (!node.global) {\n    this.word(id.type === \"Identifier\" ? \"namespace\" : \"module\");\n    this.space();\n  }\n\n  this.print(id, node);\n\n  if (!node.body) {\n    this.tokenChar(59);\n    return;\n  }\n\n  let body = node.body;\n\n  while (body.type === \"TSModuleDeclaration\") {\n    this.tokenChar(46);\n    this.print(body.id, body);\n    body = body.body;\n  }\n\n  this.space();\n  this.print(body, node);\n}\n\nfunction TSModuleBlock(node) {\n  tsPrintBraced(this, node.body, node);\n}\n\nfunction TSImportType(node) {\n  const {\n    argument,\n    qualifier,\n    typeParameters\n  } = node;\n  this.word(\"import\");\n  this.tokenChar(40);\n  this.print(argument, node);\n  this.tokenChar(41);\n\n  if (qualifier) {\n    this.tokenChar(46);\n    this.print(qualifier, node);\n  }\n\n  if (typeParameters) {\n    this.print(typeParameters, node);\n  }\n}\n\nfunction TSImportEqualsDeclaration(node) {\n  const {\n    isExport,\n    id,\n    moduleReference\n  } = node;\n\n  if (isExport) {\n    this.word(\"export\");\n    this.space();\n  }\n\n  this.word(\"import\");\n  this.space();\n  this.print(id, node);\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(moduleReference, node);\n  this.tokenChar(59);\n}\n\nfunction TSExternalModuleReference(node) {\n  this.token(\"require(\");\n  this.print(node.expression, node);\n  this.tokenChar(41);\n}\n\nfunction TSNonNullExpression(node) {\n  this.print(node.expression, node);\n  this.tokenChar(33);\n}\n\nfunction TSExportAssignment(node) {\n  this.word(\"export\");\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(node.expression, node);\n  this.tokenChar(59);\n}\n\nfunction TSNamespaceExportDeclaration(node) {\n  this.word(\"export\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.word(\"namespace\");\n  this.space();\n  this.print(node.id, node);\n}\n\nfunction tsPrintSignatureDeclarationBase(node) {\n  const {\n    typeParameters\n  } = node;\n  const parameters = node.parameters;\n  this.print(typeParameters, node);\n  this.tokenChar(40);\n\n  this._parameters(parameters, node);\n\n  this.tokenChar(41);\n  const returnType = node.typeAnnotation;\n  this.print(returnType, node);\n}\n\nfunction tsPrintClassMemberModifiers(node) {\n  const isField = node.type === \"ClassAccessorProperty\" || node.type === \"ClassProperty\";\n\n  if (isField && node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (node.accessibility) {\n    this.word(node.accessibility);\n    this.space();\n  }\n\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n\n  if (node.override) {\n    this.word(\"override\");\n    this.space();\n  }\n\n  if (node.abstract) {\n    this.word(\"abstract\");\n    this.space();\n  }\n\n  if (isField && node.readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n}"]}